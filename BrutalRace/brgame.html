<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mud & Drift Racing</title>
    <script src="https://yandex.ru/games/sdk/v2"></script>
    <style>
        :root { --primary: #e67e22; --danger: #c0392b; --mud: #5d4037; --oil: #111; --bg: #222; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0; overflow: hidden; background: var(--bg);
            font-family: monospace; color: white;
            user-select: none; -webkit-user-select: none;
            touch-action: none; position: fixed; width: 100%; height: 100%;
        }
        canvas { display: block; width: 100%; height: 100%; }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: rgba(0,0,0,0.95); z-index: 100;
        }
        .hidden { display: none !important; }

        h1 { font-size: 40px; color: var(--primary); text-transform: uppercase; text-shadow: 4px 4px 0 #000; margin-bottom: 10px;}
        p { color: #ccc; text-align: center; margin-bottom: 20px; font-size: 16px; line-height: 1.5; }

        .btn {
            padding: 20px 60px; font-size: 24px; font-weight: bold;
            background: #333; border: 3px solid var(--primary); color: var(--primary);
            cursor: pointer; text-transform: uppercase; box-shadow: 0 5px 0 #000;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; background: var(--primary); color: #000; }

        /* HUD */
        #hud-top { position: absolute; top: 15px; left: 15px; pointer-events: none; z-index: 10; font-size: 20px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        #bar-hp { width: 200px; height: 20px; background: #333; border: 2px solid #fff; transform: skewX(-20deg); margin-bottom: 5px; }
        #fill-hp { width: 100%; height: 100%; background: var(--danger); transition: width 0.2s; }
        #bar-ammo { width: 200px; height: 10px; background: #333; border: 1px solid #fff; transform: skewX(-20deg); }
        #fill-ammo { width: 100%; height: 100%; background: #f1c40f; }

        /* CONTROLS */
        .controls { position: absolute; bottom: 30px; width: 100%; height: 120px; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; pointer-events: none; z-index: 20; }
        .group { display: flex; gap: 15px; pointer-events: auto; align-items: flex-end; }
        
        .c-btn { width: 80px; height: 80px; background: rgba(50,50,50,0.8); border: 3px solid #777; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 30px; color: #fff; box-shadow: 0 4px 0 #000; }
        .c-btn:active { background: #fff; color: #000; transform: translateY(4px); box-shadow: none; }
    </style>
</head>
<body>

<div id="start-screen" class="screen">
    <h1>DIRT RALLY</h1>
    <p>–ö–æ—Ä–∏—á–Ω–µ–≤—ã–µ –ø—è—Ç–Ω–∞ = –ì–†–Ø–ó–¨ (–í—è–∑–Ω–µ—à—å)<br>–ß–µ—Ä–Ω—ã–µ –ø—è—Ç–Ω–∞ = –ú–ê–°–õ–û (–î—Ä–∏—Ñ—Ç)<br>–¢–∞—Ä–∞–Ω—å –≤—Ä–∞–≥–æ–≤!</p>
    <button class="btn" onclick="startGame()">–ì–û–ù–ö–ê</button>
</div>

<div id="gameover-screen" class="screen hidden">
    <h1 style="color:var(--danger)">FAIL</h1>
    <p>–ö—Ä—É–≥–æ–≤: <span id="final-score">0</span></p>
    <button class="btn" onclick="startGame()">–ï–©–ï –†–ê–ó</button>
</div>

<div id="hud-top">
    <div id="bar-hp"><div id="fill-hp"></div></div>
    <div id="bar-ammo"><div id="fill-ammo"></div></div>
    <div style="margin-top:5px">SPEED: <span id="speed-val">0</span></div>
</div>

<div class="controls">
    <div class="group">
        <div id="b-left" class="c-btn">‚óÑ</div>
        <div id="b-right" class="c-btn">‚ñ∫</div>
    </div>
    <div class="group">
        <div id="b-shoot" class="c-btn" style="border-color:#f1c40f; color:#f1c40f">üî•</div>
        <div id="b-gas" class="c-btn" style="border-color:#e67e22; color:#e67e22">‚ñ≤</div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- PHYSICS SETTINGS ---
    const PHYS = {
        maxSpeed: 24,       // –ú–∞–∫—Å–∏–º–∞–ª–∫–∞ (–±—ã—Å—Ç—Ä–∞—è, –Ω–æ —Ç—è–∂–µ–ª–∞—è)
        accel: 0.15,        // –†–∞–∑–≥–æ–Ω –º–µ–¥–ª–µ–Ω–Ω—ã–π (–æ—â—É—â–µ–Ω–∏–µ –≤–µ—Å–∞)
        friction: 0.98,     // –ò–Ω–µ—Ä—Ü–∏—è (–∫–∞—Ç–∏—Ç—Å—è –¥–æ–ª–≥–æ)
        turn: 0.04,         // –¢—É–≥–æ–π —Ä—É–ª—å
        grip: 0.92,         // –î—Ä–∏—Ñ—Ç
        
        // –ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
        mudSpeed: 0.6,      // –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ –≤ –≥—Ä—è–∑–∏
        oilGrip: 0.2        // –°–∫–æ–ª—å–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Å–ª–µ
    };

    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    let gameState = 'MENU';
    let keys = {};
    let player, enemies=[], particles=[], projectiles=[], patches=[];
    let laps=0, nextCP=0;
    const cam = {x:0, y:0, zoom:0.75};

    // Yandex
    setTimeout(() => {
        if(window.YaGames) YaGames.init().then(ys => ys.getLeaderboards().then(lb => window.lb = lb));
    }, 500);

    // Track Points
    const points = [
        {x:0, y:0}, {x:0, y:-4000}, {x:2500, y:-7000}, 
        {x:5500, y:-7000}, {x:7000, y:-4000}, {x:5000, y:0}, 
        {x:2000, y:2500}, {x:-2000, y:2500}, {x:-4000, y:0}
    ];
    points.forEach(p => { p.x+=3000; p.y+=6000; });

    // --- CLASSES ---
    class Patch {
        constructor(x, y, type) {
            this.x=x; this.y=y; this.type=type; // 'mud' or 'oil'
            this.r = 150 + Math.random()*100;
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º "–∫–ª—è–∫—Å—É" –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫—Ä—É–≥–æ–≤
            this.blobs = [];
            for(let i=0; i<5; i++) {
                this.blobs.push({
                    dx: (Math.random()-0.5)*this.r, 
                    dy: (Math.random()-0.5)*this.r, 
                    r: this.r * (0.4 + Math.random()*0.4)
                });
            }
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.fillStyle = this.type === 'mud' ? '#5d4037' : '#111'; // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π –∏–ª–∏ –ß–µ—Ä–Ω—ã–π
            ctx.beginPath();
            this.blobs.forEach(b => {
                ctx.moveTo(b.dx, b.dy);
                ctx.arc(b.dx, b.dy, b.r, 0, Math.PI*2);
            });
            ctx.fill();
            // –ë–ª–∏–∫–∏ –¥–ª—è –º–∞—Å–ª–∞
            if(this.type === 'oil') {
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath(); ctx.arc(20, -20, 30, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }
    }

    class Car {
        constructor(x, y, isPlayer) {
            this.x=x; this.y=y; this.isPlayer=isPlayer;
            this.angle = -Math.PI/2;
            this.speed = 0; 
            this.driftVec = {x:0, y:0};
            this.w=36; this.l=64; this.health=100;
            this.ammo = isPlayer ? 15 : 0;
            this.targetIdx=1; this.shootTimer=0;
            
            if(isPlayer) { this.color='#95a5a6'; this.mass=2.0; } // –ò–≥—Ä–æ–∫ —Ç—è–∂–µ–ª—ã–π
            else { this.color='#c0392b'; this.mass=1.0; }
        }

        update() {
            // 1. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
            let myGrip = PHYS.grip;
            let myFriction = PHYS.friction;
            let inMud = false;

            for(let p of patches) {
                // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏ –¥–æ —Ü–µ–Ω—Ç—Ä–∞ –ø—è—Ç–Ω–∞
                if((this.x-p.x)**2 + (this.y-p.y)**2 < (p.r*0.8)**2) {
                    if(p.type === 'mud') {
                        inMud = true;
                        myFriction = 0.92; // –í—è–∑–∫–æ—Å—Ç—å
                    } else {
                        myGrip = PHYS.oilGrip; // –°–∫–æ–ª—å–∂–µ–Ω–∏–µ
                        myFriction = 0.995; // –õ–µ—Ç–∏—Ç –∫–∞–∫ –ø–æ –ª—å–¥—É
                    }
                }
            }

            if(this.isPlayer) {
                // –°—Ç—Ä–µ–ª—å–±–∞
                if(keys.shoot && this.shootTimer<=0 && this.ammo>0) {
                    this.ammo--; this.shootTimer=15;
                    projectiles.push({x:this.x, y:this.y, vx:Math.cos(this.angle)*40, vy:Math.sin(this.angle)*40, life:60});
                    this.speed -= 1; 
                    AudioEngine.play('shoot');
                }
                if(this.shootTimer>0) this.shootTimer--;

                // –ì–∞–∑/–¢–æ—Ä–º–æ–∑
                if(keys.up) {
                    // –í –≥—Ä—è–∑–∏ —Ä–∞–∑–≥–æ–Ω —Ö—É–∂–µ
                    this.speed += PHYS.accel * (inMud ? 0.4 : 1.0);
                } else if(keys.down) {
                    this.speed -= PHYS.accel * 1.5;
                } else {
                    this.speed *= myFriction; // –ù–∞–∫–∞—Ç
                }

                // –õ–∏–º–∏—Ç—ã
                let maxS = PHYS.maxSpeed;
                if(inMud) maxS *= 0.6; // –í –≥—Ä—è–∑–∏ –º–∞–∫—Å —Å–∫–æ—Ä–æ—Å—Ç—å –ø–∞–¥–∞–µ—Ç
                if(this.speed > maxS) this.speed = maxS;
                if(this.speed < -8) this.speed = -8;

                // –ü–æ–≤–æ—Ä–æ—Ç
                if(Math.abs(this.speed) > 0.5) {
                    const dir = this.speed > 0 ? 1 : -1;
                    // –ù–∞ –º–∞—Å–ª–µ —Ä—É–ª—å –ø–æ—á—Ç–∏ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
                    let turnEff = (myGrip < 0.5) ? 0.3 : 1.0;
                    if(keys.left) this.angle -= PHYS.turn * turnEff * dir;
                    if(keys.right) this.angle += PHYS.turn * turnEff * dir;
                }
            } else {
                // AI
                let t = points[this.targetIdx];
                if((this.x-t.x)**2+(this.y-t.y)**2 < 100000) this.targetIdx=(this.targetIdx+1)%points.length;
                let wa = Math.atan2(t.y-this.y, t.x-this.x);
                let diff = wa - this.angle;
                while(diff<=-Math.PI) diff+=Math.PI*2; while(diff>Math.PI) diff-=Math.PI*2;
                if(diff > 0.1) this.angle += 0.04; else if(diff < -0.1) this.angle -= 0.04;
                
                let targetS = 18; 
                if(inMud) targetS = 10;
                // Rubber band
                let d = Math.hypot(player.x-this.x, player.y-this.y);
                if(d > 1000) targetS = 24; 
                
                if(this.speed < targetS) this.speed += 0.2; else this.speed *= 0.98;
            }

            // 2. –í–µ–∫—Ç–æ—Ä–Ω–∞—è —Ñ–∏–∑–∏–∫–∞ (–ò–Ω–µ—Ä—Ü–∏—è)
            const hX = Math.cos(this.angle) * this.speed;
            const hY = Math.sin(this.angle) * this.speed;

            // –°–º–µ—à–∏–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –≤–µ–∫—Ç–æ—Ä —Å –∏–Ω–µ—Ä—Ü–∏–µ–π
            this.driftVec.x = this.driftVec.x * 0.93 + hX * 0.07;
            this.driftVec.y = this.driftVec.y * 0.93 + hY * 0.07;

            // –†–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–π –≤–µ–∫—Ç–æ—Ä (Grip —Ä–µ—à–∞–µ—Ç, –∫—É–¥–∞ –µ–¥–µ–º: –∑–∞ –∫–æ–ª–µ—Å–∞–º–∏ –∏–ª–∏ –ø–æ –∏–Ω–µ—Ä—Ü–∏–∏)
            const mX = hX * myGrip + this.driftVec.x * (1 - myGrip);
            const mY = hY * myGrip + this.driftVec.y * (1 - myGrip);

            this.x += mX; 
            this.y += mY;

            // –í–∏–∑—É–∞–ª –≥—Ä—è–∑–∏/–¥—ã–º–∞
            if((inMud || (myGrip < 0.5)) && Math.abs(this.speed) > 5) {
                if(Math.random()>0.6) {
                    let color = inMud ? '#5d4037' : '#aaa';
                    particles.push({x:this.x, y:this.y, vx:0, vy:0, life:20, c:color, s:Math.random()*6+4});
                }
            }

            // –¢—Ä–∞—Å—Å–∞ (–ë–æ—Ä–¥—é—Ä—ã)
            let mD = Infinity;
            for(let i=0; i<points.length; i++) {
                const p1=points[i], p2=points[(i+1)%points.length];
                const d = distToSeg(this, p1, p2); if(d<mD) mD=d;
            }
            // –®–∏—Ä–∏–Ω–∞ —Ç—Ä–∞—Å—Å—ã 700 (350 —Ä–∞–¥–∏—É—Å)
            if(mD > 380) {
                // –ú—è–≥–∫–æ–µ –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –æ—Ç —Å—Ç–µ–Ω—ã, —á—Ç–æ–±—ã –Ω–µ –∑–∞–ª–∏–ø–∞—Ç—å
                this.speed *= 0.9;
                if(this.isPlayer && Math.abs(this.speed) > 5) {
                    this.health -= 0.1;
                    // –¢—Ä—è—Å–∫–∞
                    cam.x += (Math.random()-0.5)*10;
                    cam.y += (Math.random()-0.5)*10;
                }
            }
            
            if(this.isPlayer) AudioEngine.update(this.speed);
        }

        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            
            // –¢–µ–Ω—å
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(-18, -18, 36, 36);
            
            // –ö–æ–ª–µ—Å–∞
            ctx.fillStyle='#111'; 
            ctx.fillRect(-18, -20, 10, 12); ctx.fillRect(-18, 8, 10, 12);
            ctx.fillRect(8, -20, 10, 12); ctx.fillRect(8, 8, 10, 12);

            // –ö—É–∑–æ–≤
            ctx.fillStyle = this.color;
            ctx.fillRect(-14, -16, 28, 32);
            
            // –ö–∞–ø–æ—Ç / –ë–∞–≥–∞–∂–Ω–∏–∫
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(-14, -16, 28, 10);
            
            // –°—Ç–µ–∫–ª–æ
            ctx.fillStyle = '#111'; ctx.fillRect(-10, -4, 20, 10);

            // –£—Å–∏–ª–µ–Ω–Ω—ã–π –±–∞–º–ø–µ—Ä (–¢–∞—Ä–∞–Ω)
            ctx.fillStyle = '#555'; ctx.fillRect(-16, -22, 32, 6);

            if(this.isPlayer) {
                ctx.fillStyle='#f39c12'; ctx.fillRect(-12, -22, 6, 4); ctx.fillRect(6, -22, 6, 4); // –§–∞—Ä—ã
            }
            ctx.restore();
        }
    }

    // --- ENGINE FUNCS ---
    function distToSeg(p, v, w) { const l2=(v.x-w.x)**2+(v.y-w.y)**2; if(l2==0) return (p.x-v.x)**2+(p.y-v.y)**2; let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2; t=Math.max(0,Math.min(1,t)); return (p.x-(v.x+t*(w.x-v.x)))**2+(p.y-(v.y+t*(w.y-v.y)))**2; }

    function update() {
        if(gameState!=='GAME') return;

        player.update();
        
        // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
        for(let i=enemies.length-1; i>=0; i--) {
            let e = enemies[i];
            e.update();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞—Ä–∞–Ω–∞
            let distSq = (player.x-e.x)**2 + (player.y-e.y)**2;
            if(distSq < 3600) { // 60px
                let angle = Math.atan2(e.y-player.y, e.x-player.x);
                let force = 15; // –°–∏–ª—å–Ω—ã–π —É–¥–∞—Ä
                
                // –§–∏–∑–∏–∫–∞ —É–¥–∞—Ä–∞ (Player —Ç—è–∂–µ–ª—ã–π, Enemy –ª–µ–≥–∫–∏–π)
                e.x += Math.cos(angle) * force * 1.5; 
                e.y += Math.sin(angle) * force * 1.5;
                player.x -= Math.cos(angle) * force * 0.2; // –ò–≥—Ä–æ–∫ –ø–æ—á—Ç–∏ –Ω–µ –æ—Ç–ª–µ—Ç–∞–µ—Ç
                player.y -= Math.sin(angle) * force * 0.2;
                
                // –£—Ä–æ–Ω
                if(Math.abs(player.speed) > 10) {
                    e.health -= 30;
                    AudioEngine.play('hit');
                    for(let k=0; k<8; k++) particles.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:20, c:'#f1c40f', s:5});
                }
            }
            
            // –ü–æ–ø–∞–¥–∞–Ω–∏–µ —Ä–∞–∫–µ—Ç
            for(let j=projectiles.length-1; j>=0; j--) {
                let p = projectiles[j];
                if((e.x-p.x)**2 + (e.y-p.y)**2 < 2000) {
                    e.health-=100; projectiles.splice(j,1); AudioEngine.play('hit');
                    for(let k=0;k<15;k++) particles.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, life:30, c:'#e74c3c', s:8});
                }
            }
            
            if(e.health<=0) enemies.splice(i,1);
        }

        // Projectiles
        for(let i=projectiles.length-1; i>=0; i--) { let p=projectiles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; if(p.life<=0) projectiles.splice(i,1); }

        // Camera
        let tz = 0.75 - (Math.abs(player.speed)/30)*0.15;
        cam.zoom += (tz - cam.zoom)*0.05;
        cam.x += (player.x - cam.x)*0.1; cam.y += (player.y - cam.y)*0.1;

        // Laps
        let ncp = (nextCP+1)%points.length;
        if((player.x-points[ncp].x)**2+(player.y-points[ncp].y)**2 < 200000) {
            nextCP=ncp;
            if(nextCP===0) {
                laps++; 
                // New stuff
                enemies.push(new Car(points[0].x, points[0].y, false));
                spawnPatches();
            }
        }

        if(player.health<=0) gameOver();

        // Particles
        particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.life--; });
        particles = particles.filter(p=>p.life>0);

        // UI
        document.getElementById('fill-hp').style.width = player.health+'%';
        document.getElementById('fill-ammo').style.width = (player.ammo/20)*100+'%';
        document.getElementById('speed-val').innerText = Math.round(Math.abs(player.speed)*4);
    }

    function draw() {
        if(gameState==='MENU') { ctx.fillStyle='#111'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
        ctx.fillStyle='#222'; ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(cam.zoom, cam.zoom);
        ctx.translate(-cam.x, -cam.y);

        // Ground
        ctx.fillStyle='#1a1a1a'; 
        points.forEach(p => ctx.fillRect(p.x-1200, p.y-1200, 800, 800));

        // Road
        ctx.lineCap='round'; ctx.lineJoin='round';
        ctx.lineWidth=850; ctx.strokeStyle='#555'; // –ë–æ—Ä–¥—é—Ä
        ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let p of points) ctx.lineTo(p.x, p.y); ctx.closePath(); ctx.stroke();
        
        ctx.lineWidth=750; ctx.strokeStyle='#999'; ctx.stroke(); // –ë–µ—Ç–æ–Ω (–°–≤–µ—Ç–ª–µ–µ)
        
        ctx.lineWidth=6; ctx.strokeStyle='#fff'; ctx.setLineDash([100,200]); ctx.stroke(); ctx.setLineDash([]);

        // Patches (Mud/Oil)
        patches.forEach(p => p.draw(ctx));

        projectiles.forEach(p => { ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill(); });
        enemies.forEach(e => e.draw(ctx));
        player.draw(ctx);
        particles.forEach(p => { ctx.fillStyle=p.c; ctx.fillRect(p.x, p.y, p.s, p.s); });

        ctx.restore();
    }

    function spawnPatches() {
        let idx = Math.floor(Math.random()*points.length);
        let p1=points[idx], p2=points[(idx+1)%points.length];
        // –ì—Ä—è–∑—å
        patches.push(new Patch((p1.x+p2.x)/2 + (Math.random()-0.5)*600, (p1.y+p2.y)/2 + (Math.random()-0.5)*600, 'mud'));
        // –ú–∞—Å–ª–æ
        if(Math.random()>0.5) patches.push(new Patch((p1.x+p2.x)/2 + (Math.random()-0.5)*600, (p1.y+p2.y)/2 + (Math.random()-0.5)*600, 'oil'));
    }

    function startGame() {
        AudioEngine.init();
        if(AudioEngine.ctx && AudioEngine.ctx.state==='suspended') AudioEngine.ctx.resume();
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');
        gameState='GAME'; laps=0; nextCP=0;
        player = new Car(points[0].x, points[0].y, true);
        cam.x=player.x; cam.y=player.y;
        enemies=[]; 
        enemies.push(new Car(points[0].x+200, points[0].y+200, false));
        patches=[]; spawnPatches(); spawnPatches();
    }

    function gameOver() {
        gameState='OVER';
        document.getElementById('final-score').innerText = laps;
        document.getElementById('gameover-screen').classList.remove('hidden');
        if(window.lb) window.lb.setLeaderboardScore('laps', laps);
    }

    // Audio
    const AudioEngine = {
        ctx: null, master: null, osc: null, gain: null,
        init: function() {
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain(); this.master.gain.value = 0.2; this.master.connect(this.ctx.destination);
                this.osc = this.ctx.createOscillator(); this.osc.type = 'sawtooth';
                this.gain = this.ctx.createGain(); this.gain.gain.value = 0;
                this.osc.connect(this.gain); this.gain.connect(this.master); this.osc.start();
            } catch(e){}
        },
        update: function(s) {
            if(!this.ctx) return;
            this.osc.frequency.setTargetAtTime(60 + Math.abs(s)*5, this.ctx.currentTime, 0.1);
            this.gain.gain.setTargetAtTime(0.1, this.ctx.currentTime, 0.1);
        },
        play: function(t) {
            if(!this.ctx) return;
            const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
            o.connect(g); g.connect(this.master);
            if(t==='shoot') { o.type='square'; o.frequency.setValueAtTime(200, this.ctx.currentTime); o.frequency.linearRampToValueAtTime(50, this.ctx.currentTime+0.2); g.gain.setValueAtTime(0.3, this.ctx.currentTime); g.gain.linearRampToValueAtTime(0, this.ctx.currentTime+0.2); o.start(); o.stop(this.ctx.currentTime+0.2); }
            if(t==='hit') { o.type='noise'; o.frequency.setValueAtTime(100, this.ctx.currentTime); g.gain.setValueAtTime(0.5, this.ctx.currentTime); g.gain.linearRampToValueAtTime(0, this.ctx.currentTime+0.3); o.start(); o.stop(this.ctx.currentTime+0.3); }
        }
    };

    // Inputs
    function btn(id, k) {
        const b=document.getElementById(id);
        const s=(v)=>{keys[k]=v; v?b.style.borderColor='#fff':b.style.borderColor= (id=='b-gas'?'#e67e22':'#777');};
        b.addEventListener('touchstart', e=>{e.preventDefault();s(true)},{passive:false});
        b.addEventListener('touchend', e=>{e.preventDefault();s(false)},{passive:false});
        b.addEventListener('mousedown', ()=>s(true)); b.addEventListener('mouseup', ()=>s(false));
    }
    btn('b-gas','up'); btn('b-shoot','shoot'); btn('b-left','left'); btn('b-right','right');

    window.onkeydown=e=>{
        if(e.code=='ArrowUp')keys.up=true;
        if(e.code=='ArrowDown'||e.code=='Space')keys.shoot=true;
        if(e.code=='ArrowLeft')keys.left=true;if(e.code=='ArrowRight')keys.right=true;
    };
    window.onkeyup=e=>{
        if(e.code=='ArrowUp')keys.up=false;
        if(e.code=='ArrowDown'||e.code=='Space')keys.shoot=false;
        if(e.code=='ArrowLeft')keys.left=false;if(e.code=='ArrowRight')keys.right=false;
    };

    function loop() { requestAnimationFrame(loop); update(); draw(); }
    loop();
</script>
</body>
</html>
