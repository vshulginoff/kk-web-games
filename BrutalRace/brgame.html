<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rally Legends: Heavy Gravel</title>
    <script src="https://yandex.ru/games/sdk/v2"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap');

        :root { --rally-blue: #004488; --rally-yellow: #ffcc00; --bg: #2b2b2b; }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0; overflow: hidden; background: #111;
            font-family: 'Exo 2', sans-serif; color: white;
            user-select: none; touch-action: none; position: fixed; width: 100%; height: 100%;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 68, 136, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto; transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; }

        h1 { 
            font-size: 40px; font-weight: 900; font-style: italic; 
            text-transform: uppercase; margin: 0; letter-spacing: 2px;
            border-bottom: 4px solid var(--rally-yellow); padding-bottom: 10px;
        }
        p { font-size: 16px; color: #ccc; margin-bottom: 40px; max-width: 80%; text-align: center; }

        .btn {
            background: transparent; border: 3px solid white; color: white;
            padding: 15px 50px; font-size: 20px; font-weight: 800; text-transform: uppercase;
            cursor: pointer; transition: all 0.2s; font-family: inherit;
        }
        .btn:active { background: white; color: var(--rally-blue); transform: scale(0.95); }

        /* HUD */
        #hud-top { 
            padding: 20px; display: flex; justify-content: space-between; 
            font-weight: 900; font-size: 24px; text-shadow: 2px 2px 0 #000;
        }
        .timer-box { color: var(--rally-yellow); font-family: monospace; font-size: 32px; }
        .gear-indicator { 
            width: 50px; height: 50px; border: 3px solid white; border-radius: 5px;
            display: flex; align-items: center; justify-content: center; font-size: 28px; background: rgba(0,0,0,0.5);
        }

        /* CONTROLS */
        .controls { display: flex; justify-content: space-between; padding: 20px; pointer-events: none; margin-bottom: 20px; }
        .c-group { display: flex; gap: 20px; pointer-events: auto; align-items: flex-end; }
        .c-btn {
            width: 80px; height: 80px; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.4); border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            font-size: 32px; color: white; backdrop-filter: blur(4px);
        }
        .c-btn:active { background: rgba(255,255,255,0.3); border-color: var(--rally-yellow); }
    </style>
</head>
<body>

<div id="start-screen" class="screen">
    <h1>RALLY LEGENDS</h1>
    <p>HEAVY GRAVEL SPEC.<br>Use inertia to turn.</p>
    <button class="btn" onclick="startGame()">START STAGE</button>
</div>

<div id="gameover-screen" class="screen hidden">
    <h1>FINISHED</h1>
    <p>TIME: <span id="final-time">00:00.00</span></p>
    <button class="btn" onclick="startGame()">RESTART</button>
</div>

<div class="ui-layer">
    <div id="hud-top">
        <div id="gear" class="gear-indicator">N</div>
        <div id="timer" class="timer-box">00:00.00</div>
    </div>

    <div class="controls">
        <div class="c-group">
            <div id="b-left" class="c-btn">◄</div>
            <div id="b-right" class="c-btn">►</div>
        </div>
        <div class="c-group">
            <div id="b-brake" class="c-btn" style="border-color:#ff5555">B</div>
            <div id="b-gas" class="c-btn" style="border-color:#55ff55">A</div>
        </div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- 1. HEAVY PHYSICS CONFIG ---
    const PHYS = {
        maxSpeed: 16.5,      // Ограничено "3-й передачей". (Было 22)
        accel: 0.09,         // Тяжелый разгон. Нужно время, чтобы набрать ход. (Было 0.18)
        
        // Инерция движения вперед
        friction: 0.99,      // Почти нет трения качения. Машина тяжелая, сама не останавливается.
        
        // Рулежка
        turnSpeed: 0.038,    // Тугой руль.
        
        // Занос
        grip: 0.93,          // Держит дорогу, пока не сорвешь
        driftMass: 0.97      // Инерция бокового скольжения. Чем ближе к 1.0, тем дольше несет боком.
    };

    // --- 2. ENGINE ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    let gameState = 'MENU';
    let keys = {};
    let player;
    let particles = [];
    let trees = [];
    let startTime = 0;
    const cam = { x: 0, y: 0, zoom: 0.9 }; // Zoom ближе, т.к. скорость меньше

    // Track Generation
    const trackWidth = 450;
    const trackPoints = [];
    
    function generateTrack() {
        trackPoints.length = 0;
        let x = 0, y = 0;
        let angle = -Math.PI / 2;
        
        for(let i=0; i<6; i++) { y-=300; trackPoints.push({x, y}); } // Start straight
        
        for(let i=0; i<50; i++) {
            let curve = (Math.random() - 0.5) * 1.8; 
            let length = 500 + Math.random() * 500;
            let segments = 6;
            for(let j=0; j<segments; j++) {
                angle += curve / segments;
                x += Math.cos(angle) * (length/segments);
                y += Math.sin(angle) * (length/segments);
                trackPoints.push({x, y});
            }
        }
        
        // Forest
        trees = [];
        for(let i=0; i<trackPoints.length-1; i++) {
            let p1 = trackPoints[i], p2 = trackPoints[i+1];
            let dist = Math.hypot(p1.x-p2.x, p1.y-p2.y);
            let steps = Math.floor(dist / 80);
            for(let s=0; s<steps; s++) {
                let t = s/steps;
                let cx = p1.x + (p2.x-p1.x)*t, cy = p1.y + (p2.y-p1.y)*t;
                if(Math.random()>0.2) trees.push({ x: cx - trackWidth/2 - 80 - Math.random()*200, y: cy + (Math.random()-0.5)*100, r: 35+Math.random()*25 });
                if(Math.random()>0.2) trees.push({ x: cx + trackWidth/2 + 80 + Math.random()*200, y: cy + (Math.random()-0.5)*100, r: 35+Math.random()*25 });
            }
        }
    }

    // --- 3. CAR ---
    class RallyCar {
        constructor() {
            this.x = trackPoints[0].x;
            this.y = trackPoints[0].y + 200;
            this.angle = -Math.PI / 2;
            this.speed = 0;
            // Momentum Vectors
            this.vx = 0; this.vy = 0;
            this.finished = false;
        }

        update() {
            if(this.finished) {
                this.speed *= 0.95;
                this.x += Math.cos(this.angle)*this.speed; 
                this.y += Math.sin(this.angle)*this.speed;
                return;
            }

            // Controls
            if(keys.up) this.speed += PHYS.accel;
            else if(keys.down) this.speed -= PHYS.accel * 1.5;
            else this.speed *= PHYS.friction; // Heavy rolling

            if(this.speed > PHYS.maxSpeed) this.speed = PHYS.maxSpeed;
            if(this.speed < -5) this.speed = -5;

            // Steering (Heavy feel)
            if(Math.abs(this.speed) > 0.2) {
                let dir = this.speed > 0 ? 1 : -1;
                // На малой скорости руль крутится легче, на высокой тяжелее
                let ratio = Math.min(1, Math.abs(this.speed) / 5);
                if(keys.left) this.angle -= PHYS.turnSpeed * dir * ratio;
                if(keys.right) this.angle += PHYS.turnSpeed * dir * ratio;
            }

            // --- HEAVY PHYSICS CALC ---
            // 1. Desired Vector (Wheels)
            let wheelVx = Math.cos(this.angle) * this.speed;
            let wheelVy = Math.sin(this.angle) * this.speed;

            // 2. Inertia Vector (Previous frame)
            // driftMass: чем ближе к 1, тем больше машина хочет лететь по старому вектору
            this.vx = this.vx * PHYS.driftMass + wheelVx * (1 - PHYS.driftMass);
            this.vy = this.vy * PHYS.driftMass + wheelVy * (1 - PHYS.driftMass);

            // 3. Apply Grip
            let moveX = wheelVx * PHYS.grip + this.vx * (1 - PHYS.grip);
            let moveY = wheelVy * PHYS.grip + this.vy * (1 - PHYS.grip);

            this.x += moveX;
            this.y += moveY;
            
            // Сохраняем вектор инерции для след кадра
            this.vx = moveX;
            this.vy = moveY;

            // Dust
            let slip = Math.abs(this.angle - Math.atan2(this.vy, this.vx));
            if(slip > 0.15 && Math.abs(this.speed) > 5) {
                for(let i=0; i<2; i++) {
                    particles.push({
                        x: this.x - Math.cos(this.angle)*25 + (Math.random()-0.5)*15,
                        y: this.y - Math.sin(this.angle)*25 + (Math.random()-0.5)*15,
                        life: 30 + Math.random()*20,
                        size: 4 + Math.random()*6,
                        c: `rgba(160, 140, 120, ${0.4})`
                    });
                }
            }

            // Tree Collision
            for(let t of trees) {
                if((this.x-t.x)**2 + (this.y-t.y)**2 < (t.r + 15)**2) {
                    this.speed *= -0.4; // Heavy impact stop
                    this.vx *= -0.4; this.vy *= -0.4;
                    this.x += (this.x - t.x) * 0.1;
                    this.y += (this.y - t.y) * 0.1;
                    AudioEngine.rev(0);
                }
            }

            // Finish
            let end = trackPoints[trackPoints.length-1];
            if(Math.hypot(this.x-end.x, this.y-end.y) < 300) {
                this.finished = true;
                finishGame();
            }

            AudioEngine.rev(Math.abs(this.speed));
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(-17, -17, 34, 34);

            // Wheels (Mud flaps)
            ctx.fillStyle = '#222';
            ctx.fillRect(-17, -20, 10, 12); ctx.fillRect(-17, 8, 10, 12);
            ctx.fillRect(7, -20, 10, 12); ctx.fillRect(7, 8, 10, 12);

            // Body (Blue Rally)
            ctx.fillStyle = '#004488';
            ctx.beginPath();
            ctx.moveTo(18, -14); ctx.lineTo(18, 14);
            ctx.lineTo(-18, 14); ctx.lineTo(-18, -14);
            ctx.fill();

            // Decals (Yellow)
            ctx.fillStyle = '#ffcc00';
            ctx.fillRect(-8, -14, 12, 28); // Roof strip
            ctx.beginPath(); ctx.arc(10, 0, 5, 0, Math.PI*2); ctx.fill(); // Hood logo

            // Glass
            ctx.fillStyle = '#111';
            ctx.fillRect(-6, -10, 6, 20); // Front
            ctx.fillRect(-16, -8, 4, 16); // Rear

            // Spoiler
            ctx.fillStyle = '#003366';
            ctx.fillRect(-22, -16, 6, 32);

            // Brake Lights
            if(keys.down) {
                ctx.fillStyle = '#f00'; ctx.shadowBlur=10; ctx.shadowColor='red';
                ctx.fillRect(-18, -12, 3, 6); ctx.fillRect(-18, 6, 3, 6);
                ctx.shadowBlur=0;
            }

            ctx.restore();
        }
    }

    // --- 4. AUDIO (Deep Engine) ---
    const AudioEngine = {
        ctx: null, osc: null, gain: null,
        init: function() {
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain(); this.master.gain.value = 0.2;
                this.master.connect(this.ctx.destination);
                this.osc = this.ctx.createOscillator();
                this.osc.type = 'sawtooth'; // Deep growl
                this.osc.frequency.value = 60;
                this.gain = this.ctx.createGain(); this.gain.gain.value = 0;
                this.osc.connect(this.gain); this.gain.connect(this.master);
                this.osc.start();
            } catch(e) {}
        },
        rev: function(speed) {
            if(!this.ctx) return;
            // Lower pitch range for "heavy" feel (60Hz - 180Hz)
            let freq = 60 + (speed * 8); 
            this.osc.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.1);
            let vol = (speed > 0.1 || keys.up) ? 0.25 : 0.05;
            this.gain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);
        }
    };

    // --- 5. LOOP ---
    function update() {
        if(gameState !== 'GAME') return;

        player.update();

        // Particles
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy;
            p.life--; p.size *= 1.03;
            if(p.life <= 0) particles.splice(i,1);
        }

        // Camera
        cam.x += (player.x - cam.x) * 0.1;
        cam.y += (player.y - cam.y) * 0.1;

        // UI
        let t = (Date.now() - startTime) / 1000;
        document.getElementById('timer').innerText = t.toFixed(2);
        
        // Gear Logic (Fake)
        let s = Math.abs(player.speed);
        let g = 'N';
        if(s>0.5) g='1';
        if(s>6) g='2';
        if(s>12) g='3'; // Max gear
        if(player.speed < -0.5) g='R';
        document.getElementById('gear').innerText = g;
    }

    function draw() {
        if(gameState === 'MENU') { ctx.fillStyle='#004488'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }

        ctx.fillStyle = '#3e3832'; // Gravel color
        ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(cam.zoom, cam.zoom);
        ctx.translate(-cam.x, -cam.y);

        // Track
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.lineWidth = trackWidth + 50; 
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; // Shadow
        ctx.beginPath(); drawPath(ctx); ctx.stroke();

        ctx.lineWidth = trackWidth;
        ctx.strokeStyle = '#6d5e52'; // Track Surface
        ctx.stroke();
        
        // Tire grooves (Visual detail)
        ctx.lineWidth = trackWidth - 60;
        ctx.strokeStyle = '#65554a';
        ctx.stroke();

        // Trees
        trees.forEach(t => {
            ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.arc(t.x+15, t.y+15, t.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#2e5a25'; ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#3e7a35'; ctx.beginPath(); ctx.arc(t.x-5, t.y-5, t.r*0.6, 0, Math.PI*2); ctx.fill();
        });

        // Finish
        let end = trackPoints[trackPoints.length-1];
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(end.x, end.y, 200, 0, Math.PI*2); ctx.globalAlpha=0.3; ctx.fill(); ctx.globalAlpha=1;

        particles.forEach(p => { ctx.fillStyle=p.c; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); });
        player.draw(ctx);

        ctx.restore();
    }

    function drawPath(c) {
        c.moveTo(trackPoints[0].x, trackPoints[0].y);
        for(let i=1; i<trackPoints.length; i++) c.lineTo(trackPoints[i].x, trackPoints[i].y);
    }

    function loop() { requestAnimationFrame(loop); update(); draw(); }

    function startGame() {
        AudioEngine.init();
        if(AudioEngine.ctx && AudioEngine.ctx.state==='suspended') AudioEngine.ctx.resume();
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');
        
        generateTrack();
        player = new RallyCar();
        cam.x = player.x; cam.y = player.y;
        particles = [];
        startTime = Date.now();
        gameState = 'GAME';
    }

    function finishGame() {
        let t = (Date.now()-startTime)/1000;
        document.getElementById('final-time').innerText = t.toFixed(2);
        document.getElementById('gameover-screen').classList.remove('hidden');
    }

    // Input
    function bind(id, k) {
        const b = document.getElementById(id);
        const s = (v) => { keys[k] = v; v?b.style.opacity=0.6:b.style.opacity=1; };
        b.addEventListener('touchstart', e=>{e.preventDefault(); s(true)},{passive:false});
        b.addEventListener('touchend', e=>{e.preventDefault(); s(false)},{passive:false});
        b.addEventListener('mousedown', ()=>s(true)); b.addEventListener('mouseup', ()=>s(false));
    }
    bind('b-gas','up'); bind('b-brake','down'); bind('b-left','left'); bind('b-right','right');

    window.onkeydown=e=>{ if(e.code=='ArrowUp')keys.up=true; if(e.code=='ArrowDown')keys.down=true; if(e.code=='ArrowLeft')keys.left=true; if(e.code=='ArrowRight')keys.right=true; };
    window.onkeyup=e=>{ if(e.code=='ArrowUp')keys.up=false; if(e.code=='ArrowDown')keys.down=false; if(e.code=='ArrowLeft')keys.left=false; if(e.code=='ArrowRight')keys.right=false; };

    loop();
</script>
</body>
</html>
