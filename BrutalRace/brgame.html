<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heavy Metal Racing</title>
    <script src="https://yandex.ru/games/sdk/v2"></script>
    <style>
        :root { --primary: #e67e22; --danger: #c0392b; --ammo: #f1c40f; --bg: #0a0a0a; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0; overflow: hidden; background: var(--bg);
            font-family: 'Courier New', monospace; color: #ccc;
            user-select: none; -webkit-user-select: none;
            touch-action: none; position: fixed; width: 100%; height: 100%;
        }
        canvas { display: block; width: 100%; height: 100%; }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: rgba(0,0,0,0.95); z-index: 100;
        }
        .hidden { display: none !important; }

        h1 { 
            font-size: 36px; color: var(--primary); margin: 0 0 20px 0; 
            text-align: center; text-transform: uppercase; letter-spacing: 5px;
            text-shadow: 0 0 15px var(--danger); border-bottom: 2px solid var(--primary);
        }
        p { color: #888; margin-bottom: 30px; text-align: center; font-size: 14px; line-height: 1.5; }

        .btn {
            padding: 15px 40px; font-size: 24px; font-weight: bold; font-family: inherit;
            background: #222; border: 2px solid var(--primary); color: var(--primary);
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: all 0.1s;
        }
        .btn:active { background: var(--primary); color: #000; transform: scale(0.95); }

        /* HUD */
        #hud-top { 
            position: absolute; top: 15px; left: 15px; width: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; gap: 8px;
        }
        .bar-wrap {
            width: 200px; height: 18px; background: #111; 
            border: 2px solid #444; transform: skewX(-20deg); position: relative;
        }
        #hp-fill { width: 100%; height: 100%; background: var(--danger); transition: width 0.2s; }
        #ammo-fill { width: 100%; height: 100%; background: var(--ammo); width: 100%; }
        .hud-text { font-size: 20px; font-weight: bold; color: #fff; text-shadow: 2px 2px 0 #000; margin-left: 5px;}

        /* CONTROLS */
        .controls { position: absolute; bottom: 30px; width: 100%; height: 120px; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; pointer-events: none; z-index: 20; }
        .group { display: flex; gap: 20px; pointer-events: auto; align-items: flex-end; }
        
        .c-btn { 
            width: 80px; height: 80px; 
            background: rgba(30,30,30,0.8); border: 2px solid #555; 
            border-radius: 12px; display: flex; align-items: center; justify-content: center; 
            font-size: 32px; color: #888; box-shadow: 0 4px 0 #000;
        }
        .c-btn:active { transform: translateY(4px); box-shadow: none; background: #444; color: #fff; }
        #b-shoot { border-color: var(--danger); color: var(--danger); }
        #b-shoot:active { background: var(--danger); color: #fff; }
        #b-gas { border-color: var(--primary); color: var(--primary); }
        #b-gas:active { background: var(--primary); color: #000; }

        /* LEADERBOARD */
        .lb-box { width: 300px; background: #111; border: 1px solid #444; padding: 10px; margin-bottom: 20px; }
        .lb-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding: 5px; color: #888; font-size: 14px; }
        .lb-row.me { color: var(--primary); }
    </style>
</head>
<body>

<div id="start-screen" class="screen">
    <h1>HEAVY METAL<br>RACING</h1>
    <p>–ú–∞—à–∏–Ω–∞ —Ç—è–∂–µ–ª–∞—è. –ò—Å–ø–æ–ª—å–∑—É–π –∏–Ω–µ—Ä—Ü–∏—é.<br>–°—Ç—Ä–µ–ª—è–π, —á—Ç–æ–±—ã –≤—ã–∂–∏—Ç—å.</p>
    <button class="btn" onclick="startGame()">START</button>
</div>

<div id="gameover-screen" class="screen hidden">
    <h1 style="color:var(--danger); border-color:var(--danger)">WRECKED</h1>
    <div class="lb-box" id="lb-content">Loading...</div>
    <button class="btn" onclick="startGame()">RETRY</button>
</div>

<div id="hud-top">
    <div class="bar-wrap"><div id="hp-fill"></div></div>
    <div class="bar-wrap" style="border-color:#554400"><div id="ammo-fill"></div></div>
    <div class="hud-text">LAP: <span id="lap-counter">1</span></div>
</div>

<div class="controls">
    <div class="group">
        <div id="b-left" class="c-btn">‚óÑ</div>
        <div id="b-right" class="c-btn">‚ñ∫</div>
    </div>
    <div class="group">
        <div id="b-shoot" class="c-btn">üî•</div>
        <div id="b-gas" class="c-btn">‚ñ≤</div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- 1. PHYSICS CONFIG (HEAVY FEEL) ---
    const PHYS = {
        maxSpeed: 12.5,      // –°–Ω–∏–∂–µ–Ω–∞ –¥–ª—è –≤–µ—Å–∞ (–±—ã–ª–æ 17)
        accel: 0.18,         // –ú–µ–¥–ª–µ–Ω–Ω—ã–π —Ä–∞–∑–≥–æ–Ω (—Ç—è–∂–µ—Å—Ç—å)
        
        // –ì–ª–∞–≤–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –∏–Ω–µ—Ä—Ü–∏–∏:
        // 0.99 = –ª–µ–¥ (–∫–∞—Ç–∏—Ç—Å—è –≤–µ—á–Ω–æ), 0.90 = –ª–µ–≥–∫–æ–≤—É—à–∫–∞.
        // 0.98 = —Ç—è–∂–µ–ª—ã–π –≥—Ä—É–∑–æ–≤–∏–∫.
        friction: 0.98,      
        
        turnSpeed: 0.04,     // –ú–µ–¥–ª–µ–Ω–Ω—ã–π —Ä—É–ª—å
        
        // –°—Ü–µ–ø–ª–µ–Ω–∏–µ:
        // 1.0 = —Ä–µ–ª—å—Å—ã. 0.9 = –¥—Ä–∏—Ñ—Ç.
        // 0.94 = —á—É–≤—Å—Ç–≤—É–µ—Ç—Å—è –≤–µ—Å –Ω–∞ –ø–æ–≤–æ—Ä–æ—Ç–∞—Ö
        grip: 0.94,
        
        recoil: 0.8          // –û—Ç–¥–∞—á–∞ –æ—Ç –≤—ã—Å—Ç—Ä–µ–ª–∞
    };

    // --- 2. SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    // –ö–∞–º–µ—Ä–∞ (Lazy Follow)
    const cam = { x:0, y:0, zoom: 1.0 };

    let gameState = 'MENU';
    let keys = {};
    let player, enemies=[], particles=[], projectiles=[], pickups=[];
    let laps=0, nextCP=0;
    
    // Yandex
    let ysdk=null, lb=null;
    setTimeout(()=>{
        if(window.YaGames) YaGames.init().then(y=>{ ysdk=y; y.getLeaderboards().then(l=>lb=l); });
    }, 500);

    // Track (Industrial Loop)
    const points = [
        {x:0, y:0}, {x:0, y:-3000}, {x:2000, y:-5000}, 
        {x:4000, y:-5000}, {x:6000, y:-3000}, {x:4000, y:0}, 
        {x:2000, y:2000}, {x:-2000, y:2000}, {x:-3000, y:0}
    ];
    points.forEach(p => { p.x+=3000; p.y+=4000; });

    // --- 3. CLASSES ---
    class Car {
        constructor(x, y, isPlayer) {
            this.x=x; this.y=y; this.isPlayer=isPlayer;
            this.angle = -Math.PI/2;
            this.speed = 0; 
            // –í–µ–∫—Ç–æ—Ä —Å–∫–æ–ª—å–∂–µ–Ω–∏—è (–¥–ª—è –∏–Ω–µ—Ä—Ü–∏–∏)
            this.driftVec = {x:0, y:0};
            
            this.w=34; this.l=60; this.health=100;
            this.ammo = isPlayer ? 10 : 0;
            this.targetIdx=1; this.shootTimer=0;
            
            if(isPlayer) { this.color='#7f8c8d'; this.max=PHYS.maxSpeed; }
            else { this.color='#c0392b'; this.max=PHYS.maxSpeed * 0.9; } // –í—Ä–∞–≥–∏ —á—É—Ç—å –º–µ–¥–ª–µ–Ω–Ω–µ–µ
        }

        update() {
            if(this.isPlayer) {
                // Shoot
                if(keys.shoot && this.shootTimer<=0 && this.ammo>0) {
                    this.ammo--; this.shootTimer=20;
                    projectiles.push({x:this.x + Math.cos(this.angle)*40, y:this.y + Math.sin(this.angle)*40, vx:Math.cos(this.angle)*30, vy:Math.sin(this.angle)*30, life:60});
                    this.speed -= PHYS.recoil; // –û—Ç–¥–∞—á–∞
                    playSound(400, 'square');
                }
                if(this.shootTimer>0) this.shootTimer--;

                // Movement Input
                if(keys.up) this.speed += PHYS.accel;
                else if(keys.down) this.speed -= PHYS.accel; // –¢–æ—Ä–º–æ–∑/–†–µ–≤–µ—Ä—Å
                
                // –¢—Ä–µ–Ω–∏–µ (–ò–Ω–µ—Ä—Ü–∏—è)
                // –ï—Å–ª–∏ –≥–∞–∑ –Ω–µ –Ω–∞–∂–∞—Ç, —Å–∫–æ—Ä–æ—Å—Ç—å –ø–∞–¥–∞–µ—Ç –æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ (–Ω–∞–∫–∞—Ç)
                if(!keys.up && !keys.down) this.speed *= PHYS.friction;

                // –†—É–ª–µ–∂–∫–∞ (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏)
                if(Math.abs(this.speed) > 0.5) {
                    const dir = this.speed > 0 ? 1 : -1;
                    if(keys.left) this.angle -= PHYS.turnSpeed * dir;
                    if(keys.right) this.angle += PHYS.turnSpeed * dir;
                }
            } else {
                // AI
                let t = points[this.targetIdx];
                if((this.x-t.x)**2+(this.y-t.y)**2 < 100000) this.targetIdx = (this.targetIdx+1)%points.length;
                let wa = Math.atan2(t.y-this.y, t.x-this.x);
                let diff = wa - this.angle;
                while(diff <= -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                if(diff > 0.1) this.angle += 0.04; else if(diff < -0.1) this.angle -= 0.04;
                
                let targetS = 11;
                // Rubber band
                let d2p = Math.hypot(player.x-this.x, player.y-this.y);
                if(d2p > 900) targetS = 16; 
                else if(d2p < 200) targetS = 10;

                if(this.speed < targetS) this.speed += 0.15; else this.speed *= 0.98;
            }

            // --- HEAVY PHYSICS CALCULATION ---
            // –õ–∏–º–∏—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏
            if(this.speed > this.max) this.speed = this.max;
            if(this.speed < -4) this.speed = -4;

            // –í–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–ª–µ—Å
            const headX = Math.cos(this.angle) * this.speed;
            const headY = Math.sin(this.angle) * this.speed;

            // –°–º–µ—à–∏–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –≤–µ–∫—Ç–æ—Ä —Å –≤–µ–∫—Ç–æ—Ä–æ–º –∏–Ω–µ—Ä—Ü–∏–∏ (Drift)
            // –ß–µ–º –º–µ–Ω—å—à–µ Grip, —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ –º–∞—à–∏–Ω—É –Ω–µ—Å–µ—Ç –ø–æ —Å—Ç–∞—Ä–æ–π —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
            this.driftVec.x = this.driftVec.x * 0.92 + headX * 0.08; 
            this.driftVec.y = this.driftVec.y * 0.92 + headY * 0.08;

            const finalX = headX * PHYS.grip + this.driftVec.x * (1 - PHYS.grip);
            const finalY = headY * PHYS.grip + this.driftVec.y * (1 - PHYS.grip);

            this.x += finalX;
            this.y += finalY;

            // –ß–∞—Å—Ç–∏—Ü—ã –¥—ã–º–∞ –ø—Ä–∏ —Ä–µ–∑–∫–∏—Ö –ø–æ–≤–æ—Ä–æ—Ç–∞—Ö (–¥—Ä–∏—Ñ—Ç–µ)
            if(Math.abs(this.speed) > 8 && Math.abs(headX - finalX) > 0.5) {
                if(Math.random()>0.7) particles.push({x:this.x, y:this.y, vx:0, vy:0, life:20, c:'rgba(100,100,100,0.5)', s:4});
            }

            // –¢—Ä–∞–≤–∞
            let mD = Infinity;
            for(let i=0; i<points.length; i++) {
                const p1=points[i], p2=points[(i+1)%points.length];
                const d = distToSeg(this, p1, p2); if(d<mD) mD=d;
            }
            if(mD > 350) { // –®–∏—Ä–∏–Ω–∞ 700/2
                this.speed *= 0.9;
                if(this.isPlayer && Math.abs(this.speed)>3) this.health-=0.2;
            }
        }

        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            // Shadow
            ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(-14, -14, 32, 28);
            // Body
            ctx.fillStyle=this.color;
            roundRect(ctx, -16, -14, 32, 28, 6);
            // Roof
            ctx.fillStyle='#222'; ctx.fillRect(-6, -12, 16, 24);
            // Window
            ctx.fillStyle='#111'; ctx.fillRect(0, -10, 8, 20);
            
            if(this.isPlayer) {
                // Lights
                ctx.fillStyle='#f1c40f'; ctx.fillRect(12, -12, 4, 6); ctx.fillRect(12, 6, 4, 6);
                // Brake lights
                if(!keys.up) {
                    ctx.fillStyle='#f00'; ctx.shadowBlur=10; ctx.shadowColor='#f00';
                    ctx.fillRect(-16, -12, 2, 6); ctx.fillRect(-16, 6, 2, 6);
                    ctx.shadowBlur=0;
                }
            } else {
                ctx.fillStyle='#111'; ctx.fillRect(-10, -5, 20, 10); // Stripe
            }
            ctx.restore();
        }
    }

    // --- ENGINE ---
    function update() {
        if(gameState!=='GAME') return;

        player.update();
        enemies.forEach((e, i) => {
            e.update();
            // Projectile hits
            for(let j=projectiles.length-1; j>=0; j--) {
                let p = projectiles[j];
                if((e.x-p.x)**2+(e.y-p.y)**2 < 2000) {
                    e.health-=100; projectiles.splice(j,1); playSound(100, 'sawtooth');
                    for(let k=0;k<10;k++) particles.push({x:e.x,y:e.y,vx:(Math.random()-0.5)*10,vy:(Math.random()-0.5)*10,life:30,c:'#e74c3c',s:6});
                }
            }
            if(e.health<=0) enemies.splice(i,1);
        });

        // Pickups
        for(let i=pickups.length-1; i>=0; i--) {
            let p = pickups[i];
            if((player.x-p.x)**2+(player.y-p.y)**2 < 3600) {
                if(p.type==='hp') player.health = Math.min(100, player.health+50);
                else player.ammo = Math.min(20, player.ammo+5);
                playSound(600, 'sine');
                pickups.splice(i,1);
            }
        }

        // Projectiles move
        for(let i=projectiles.length-1; i>=0; i--) {
            let p = projectiles[i]; p.x+=p.vx; p.y+=p.vy; p.life--;
            if(p.life<=0) projectiles.splice(i,1);
        }

        // Camera Follow (Smooth)
        cam.x += (player.x - cam.x) * 0.1;
        cam.y += (player.y - cam.y) * 0.1;

        // Laps
        let ncp = (nextCP+1)%points.length;
        if((player.x-points[ncp].x)**2+(player.y-points[ncp].y)**2 < 150000) {
            nextCP=ncp; 
            if(nextCP===0) {
                laps++; 
                // New enemy every lap
                let sp=points[0]; 
                let e=new Car(sp.x, sp.y, false); e.targetIdx=1; enemies.push(e);
                // Loot
                spawnLoot();
            }
        }

        if(player.health<=0) gameOver();

        // Particles
        particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.life--; });
        particles = particles.filter(p=>p.life>0);

        // UI
        document.getElementById('lap-counter').innerText = laps+1;
        document.getElementById('hp-fill').style.width = player.health+'%';
        document.getElementById('ammo-fill').style.width = (player.ammo/20)*100+'%';
    }

    function draw() {
        if(gameState==='MENU') { ctx.fillStyle='#111'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
        
        ctx.fillStyle='#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        // –ö–∞–º–µ—Ä–∞ —Å–¥–≤–∏–Ω—É—Ç–∞
        ctx.translate(-cam.x, -cam.y);

        // Decor (Factories)
        ctx.fillStyle='#181818';
        points.forEach(p => ctx.fillRect(p.x-900, p.y-900, 500, 500));

        // Road
        ctx.lineCap='round'; ctx.lineJoin='round';
        ctx.lineWidth=760; ctx.strokeStyle='#e67e22'; // Rusty Border
        ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let p of points) ctx.lineTo(p.x, p.y); ctx.closePath(); ctx.stroke();
        
        ctx.lineWidth=700; ctx.strokeStyle='#333'; ctx.stroke(); // Asphalt
        
        ctx.lineWidth=6; ctx.strokeStyle='#555'; ctx.setLineDash([100,150]); ctx.stroke(); ctx.setLineDash([]);

        pickups.forEach(p => {
            ctx.fillStyle = p.type==='hp'?'#2ecc71':'#f1c40f';
            ctx.beginPath(); ctx.arc(p.x, p.y, 15, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#000'; ctx.font='20px monospace'; ctx.fillText(p.type==='hp'?'+':'!', p.x-5, p.y+5);
        });

        projectiles.forEach(p => { ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill(); });
        enemies.forEach(e => e.draw(ctx));
        player.draw(ctx);
        particles.forEach(p => { ctx.fillStyle=p.c; ctx.fillRect(p.x, p.y, p.s, p.s); });

        ctx.restore();
    }

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');
        
        // Sound Context Unlock
        try {
            const AC = window.AudioContext || window.webkitAudioContext;
            if(!window.audioCtx) window.audioCtx = new AC();
            if(window.audioCtx.state === 'suspended') window.audioCtx.resume();
        } catch(e){}

        gameState = 'GAME';
        laps=0; nextCP=0;
        player = new Car(points[0].x, points[0].y, true);
        cam.x = player.x; cam.y = player.y; // –°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã
        enemies=[]; 
        enemies.push(new Car(points[0].x+150, points[0].y+150, false));
        pickups=[]; projectiles=[]; spawnLoot();
    }

    function spawnLoot() {
        ['hp','ammo'].forEach(t => {
            let i = Math.floor(Math.random()*points.length);
            let p1=points[i], p2=points[(i+1)%points.length];
            pickups.push({x:(p1.x+p2.x)/2 + (Math.random()-0.5)*400, y:(p1.y+p2.y)/2 + (Math.random()-0.5)*400, type:t});
        });
    }

    function gameOver() {
        gameState='OVER';
        document.getElementById('gameover-screen').classList.remove('hidden');
        if(lb) {
            lb.setLeaderboardScore('laps', laps);
            lb.getLeaderboardEntries('laps', { quantityTop: 5, includeUser: true }).then(res => {
                let html='';
                res.entries.forEach(e => html+=`<div class="lb-row ${e.player.uniqueID===res.userRank?'me':''}"><span>#${e.rank} ${e.player.publicName||'Pilot'}</span><span>${e.score}</span></div>`);
                document.getElementById('lb-content').innerHTML = html;
            });
        }
        if(ysdk) ysdk.adv.showFullscreenAdv({callbacks:{}});
    }

    // --- UTILS ---
    function roundRect(ctx, x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r); ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y); ctx.fill(); }
    function distToSeg(p, v, w) { const l2=(v.x-w.x)**2+(v.y-w.y)**2; if(l2==0) return (p.x-v.x)**2+(p.y-v.y)**2; let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2; t=Math.max(0,Math.min(1,t)); return (p.x-(v.x+t*(w.x-v.x)))**2+(p.y-(v.y+t*(w.y-v.y)))**2; }
    
    function playSound(f, type) {
        if(!window.audioCtx) return;
        const o=window.audioCtx.createOscillator(); const g=window.audioCtx.createGain();
        o.type=type; o.frequency.setValueAtTime(f, window.audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(10, window.audioCtx.currentTime+0.2);
        g.gain.setValueAtTime(0.1, window.audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, window.audioCtx.currentTime+0.2);
        o.connect(g); g.connect(window.audioCtx.destination);
        o.start(); o.stop(window.audioCtx.currentTime+0.2);
    }

    // --- CONTROLS ---
    function btn(id, k) {
        const b=document.getElementById(id);
        const s=(v)=>{keys[k]=v; v?b.style.opacity=0.5:b.style.opacity=1;};
        b.ontouchstart=e=>{e.preventDefault();s(true)};
        b.ontouchend=e=>{e.preventDefault();s(false)};
        b.onmousedown=()=>s(true); b.onmouseup=()=>s(false);
    }
    btn('b-gas','up'); btn('b-shoot','shoot'); btn('b-left','left'); btn('b-right','right');
    
    window.onkeydown=e=>{if(e.code=='ArrowUp')keys.up=true;if(e.code=='ArrowDown'||e.code=='Space')keys.shoot=true;if(e.code=='ArrowLeft')keys.left=true;if(e.code=='ArrowRight')keys.right=true;};
    window.onkeyup=e=>{if(e.code=='ArrowUp')keys.up=false;if(e.code=='ArrowDown'||e.code=='Space')keys.shoot=false;if(e.code=='ArrowLeft')keys.left=false;if(e.code=='ArrowRight')keys.right=false;};

    function loop() { requestAnimationFrame(loop); update(); draw(); }
    loop();
</script>
</body>
</html>
