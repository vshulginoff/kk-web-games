<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Drift Racing: Heavy Metal</title>
    
    <script src="https://yandex.ru/games/sdk/v2"></script>

    <style>
        :root { --primary: #ff9f43; --danger: #ee5253; --oil: #000; --bg: #1e1e1e; }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0; overflow: hidden; background: var(--bg);
            font-family: 'Courier New', monospace; color: white;
            user-select: none; -webkit-user-select: none;
            touch-action: none; position: fixed; width: 100%; height: 100%;
        }
        canvas { display: block; width: 100%; height: 100%; }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: rgba(0,0,0,0.95); z-index: 100; transition: opacity 0.3s;
        }
        .hidden { display: none !important; }

        h1 { 
            font-size: 40px; color: var(--primary); margin: 0 0 10px 0; 
            text-align: center; font-weight: 900; letter-spacing: -2px;
            text-shadow: 4px 4px 0 #000; font-style: italic;
        }
        p { color: #bbb; margin-bottom: 30px; text-align: center; font-size: 16px; }

        .btn {
            padding: 20px 60px; font-size: 24px; font-weight: bold; font-family: inherit;
            background: #222; border: 3px solid var(--primary); color: var(--primary);
            cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 159, 67, 0.2);
        }
        .btn:active { background: var(--primary); color: #000; transform: scale(0.95); }

        /* HUD */
        #hud-top { 
            position: absolute; top: 15px; left: 15px; 
            font-weight: bold; font-size: 18px; pointer-events: none; z-index: 10;
            text-shadow: 1px 1px 0 #000;
        }
        
        .bar-wrap {
            width: 200px; height: 16px; background: #333; 
            border: 2px solid #777; transform: skewX(-20deg); margin-bottom: 5px;
        }
        #hp-fill { width: 100%; height: 100%; background: var(--danger); transition: width 0.1s; }
        #speed-text { font-size: 24px; color: var(--primary); margin-top: 5px; }

        /* CONTROLS */
        .controls { position: absolute; bottom: 30px; width: 100%; height: 120px; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; pointer-events: none; z-index: 20; }
        .group { display: flex; gap: 15px; pointer-events: auto; align-items: flex-end; }
        
        .c-btn { width: 80px; height: 80px; background: rgba(50,50,50,0.6); border: 2px solid #999; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 32px; color: #fff; backdrop-filter: blur(5px); }
        .c-btn:active { background: #fff; color: #000; transform: scale(0.95); }
    </style>
</head>
<body>

<div id="start-screen" class="screen">
    <h1>DRIFT RACING</h1>
    <p>–û—Å—Ç–æ—Ä–æ–∂–Ω–æ: –ß–µ—Ä–Ω—ã–µ –ø—è—Ç–Ω–∞ - —ç—Ç–æ –ú–ê–°–õ–û.<br>–ù–∞ –Ω–∏—Ö —Å—Ü–µ–ø–ª–µ–Ω–∏—è –ù–ï–¢.</p>
    <button class="btn" onclick="startGame()">START</button>
</div>

<div id="gameover-screen" class="screen hidden">
    <h1 style="color:var(--danger)">WRECKED</h1>
    <p>Laps: <span id="final-score">0</span></p>
    <div id="lb-content" style="color:#888; margin-bottom:20px; font-size:14px;"></div>
    <button class="btn" onclick="startGame()">RETRY</button>
</div>

<div id="hud-top">
    <div class="bar-wrap"><div id="hp-fill"></div></div>
    <div>LAP: <span id="lap-counter">1</span></div>
    <div id="speed-text">0 KM/H</div>
</div>

<div class="controls">
    <div class="group">
        <div id="b-left" class="c-btn">‚óÑ</div>
        <div id="b-right" class="c-btn">‚ñ∫</div>
    </div>
    <div class="group">
        <div id="b-shoot" class="c-btn" style="border-color:var(--danger)">üî•</div>
        <div id="b-gas" class="c-btn" style="border-color:var(--primary)">‚ñ≤</div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- PHYSICS CONFIGURATION (HEAVY & FAST) ---
    const PHYS = {
        // –°–∫–æ—Ä–æ—Å—Ç—å –∏ –∏–Ω–µ—Ä—Ü–∏—è
        maxSpeed: 28,        // –í—ã—Å–æ–∫–∞—è –º–∞–∫—Å–∏–º–∞–ª–∫–∞ (–æ—â—É—â–µ–Ω–∏–µ 80-100 –∫–º/—á)
        accel: 0.15,         // –ú–µ–¥–ª–µ–Ω–Ω—ã–π —Ä–∞–∑–≥–æ–Ω (—Ç—è–∂–µ—Å—Ç—å)
        friction: 0.985,     // –û–ß–ï–ù–¨ –Ω–∏–∑–∫–æ–µ —Ç—Ä–µ–Ω–∏–µ (–¥–æ–ª–≥–æ –∫–∞—Ç–∏—Ç—Å—è –ø–æ –∏–Ω–µ—Ä—Ü–∏–∏)
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        turnSpeed: 0.038,    // –¢—è–∂–µ–ª—ã–π —Ä—É–ª—å
        
        // –°—Ü–µ–ø–ª–µ–Ω–∏–µ (Grip)
        gripNormal: 0.93,    // –û–±—ã—á–Ω—ã–π –∞—Å—Ñ–∞–ª—å—Ç (–Ω–µ–º–Ω–æ–≥–æ –∑–∞–Ω–æ—Å–∏—Ç)
        gripOil: 0.85,       // –ú–∞—Å–ª–æ (—Å–∏–ª—å–Ω–æ –Ω–µ—Å–µ—Ç –±–æ–∫–æ–º)
        frictionOil: 0.995   // –ù–∞ –º–∞—Å–ª–µ –ø–æ—á—Ç–∏ –Ω–µ —Ç–µ—Ä—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
    };

    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    let gameState = 'MENU';
    let keys = {};
    let player, enemies=[], particles=[], projectiles=[], pickups=[], oils=[];
    let laps=0, nextCP=0;
    
    // Yandex
    let ysdk=null, lb=null;
    setTimeout(()=>{ if(window.YaGames) YaGames.init().then(y=>{ ysdk=y; y.getLeaderboards().then(l=>lb=l); }); }, 500);

    // Track
    const points = [
        {x:0, y:0}, {x:0, y:-4000}, {x:2500, y:-7000}, 
        {x:5500, y:-7000}, {x:7000, y:-4000}, {x:5000, y:0}, 
        {x:2000, y:2500}, {x:-2000, y:2500}, {x:-4000, y:0}
    ];
    points.forEach(p => { p.x+=3000; p.y+=6000; });

    // Camera
    const cam = { x:0, y:0, zoom: 0.7 };

    // --- CLASSES ---
    class OilSlick {
        constructor(x, y, r) {
            this.x = x; this.y = y; this.r = r;
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.fillStyle = 'rgba(10, 10, 10, 0.8)'; // –ß–µ—Ä–Ω–æ–µ –º–∞—Å–ª–æ
            ctx.beginPath(); 
            // –†–∏—Å—É–µ–º –∫–ª—è–∫—Å—É
            ctx.arc(0, 0, this.r, 0, Math.PI*2);
            ctx.arc(10, 10, this.r/2, 0, Math.PI*2);
            ctx.arc(-15, 5, this.r/3, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }

    class Car {
        constructor(x, y, isPlayer) {
            this.x=x; this.y=y; this.isPlayer=isPlayer;
            this.angle = -Math.PI/2;
            this.speed = 0; 
            this.driftVec = {x:0, y:0}; // –í–µ–∫—Ç–æ—Ä –¥—Ä–∏—Ñ—Ç–∞
            this.w=34; this.l=62; this.health=100;
            this.ammo = isPlayer ? 10 : 0;
            this.shootTimer=0; this.targetIdx=1;
            
            if(isPlayer) { this.color='#bdc3c7'; }
            else { this.color='#c0392b'; }
        }

        update() {
            // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
            let currentGrip = PHYS.gripNormal;
            let currentFriction = PHYS.friction;
            let onOil = false;

            for(let oil of oils) {
                if ((this.x-oil.x)**2 + (this.y-oil.y)**2 < (oil.r+20)**2) {
                    currentGrip = PHYS.gripOil;
                    currentFriction = PHYS.frictionOil;
                    onOil = true;
                }
            }

            if(this.isPlayer) {
                // Shoot
                if(keys.shoot && this.shootTimer<=0 && this.ammo>0) {
                    this.ammo--; this.shootTimer=20;
                    projectiles.push({x:this.x+Math.cos(this.angle)*40, y:this.y+Math.sin(this.angle)*40, vx:Math.cos(this.angle)*40, vy:Math.sin(this.angle)*40, life:60});
                    this.speed -= 1.0; // –û—Ç–¥–∞—á–∞ —Å–∏–ª—å–Ω–µ–µ
                    AudioEngine.play('shoot');
                }
                if(this.shootTimer>0) this.shootTimer--;

                // Movement
                if(keys.up) this.speed += PHYS.accel;
                else if(keys.down) this.speed -= PHYS.accel * 1.5; // –¢–æ—Ä–º–æ–∑ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–µ–µ
                
                // –ò–Ω–µ—Ä—Ü–∏—è
                if(!keys.up && !keys.down) this.speed *= currentFriction;

                // –†—É–ª–µ–∂–∫–∞ (–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–∞–¥–∞–µ—Ç –Ω–∞ –ª—å–¥—É/–º–∞—Å–ª–µ)
                let turnEff = onOil ? 0.4 : 1.0;
                
                if(Math.abs(this.speed) > 0.5) {
                    const dir = this.speed > 0 ? 1 : -1;
                    if(keys.left) this.angle -= PHYS.turnSpeed * turnEff * dir;
                    if(keys.right) this.angle += PHYS.turnSpeed * turnEff * dir;
                }
            } else {
                // AI
                let t = points[this.targetIdx];
                if((this.x-t.x)**2+(this.y-t.y)**2 < 100000) this.targetIdx = (this.targetIdx+1)%points.length;
                let wa = Math.atan2(t.y-this.y, t.x-this.x);
                let diff = wa - this.angle;
                while(diff <= -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                if(diff > 0.1) this.angle += 0.04; else if(diff < -0.1) this.angle -= 0.04;
                
                let targetS = 22; // –í—Ä–∞–≥–∏ –±—ã—Å—Ç—Ä—ã–µ
                if(this.speed < targetS) this.speed += 0.15; else this.speed *= 0.99;
            }

            // --- PHYSICS ENGINE ---
            if(this.speed > PHYS.maxSpeed) this.speed = PHYS.maxSpeed;
            if(this.speed < -8) this.speed = -8;

            // –ö—É–¥–∞ —Å–º–æ—Ç—Ä—è—Ç –∫–æ–ª–µ—Å–∞
            const hX = Math.cos(this.angle) * this.speed;
            const hY = Math.sin(this.angle) * this.speed;

            // –ò–Ω–µ—Ä—Ü–∏—è (Drift Vector)
            // –ü–ª–∞–≤–Ω–æ–µ –ø–µ—Ä–µ—Ç–µ–∫–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏
            this.driftVec.x = this.driftVec.x * 0.95 + hX * 0.05; 
            this.driftVec.y = this.driftVec.y * 0.95 + hY * 0.05;

            // –†–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–π –≤–µ–∫—Ç–æ—Ä
            const moveX = hX * currentGrip + this.driftVec.x * (1 - currentGrip);
            const moveY = hY * currentGrip + this.driftVec.y * (1 - currentGrip);

            this.x += moveX;
            this.y += moveY;

            // –ß–∞—Å—Ç–∏—Ü—ã –Ω–∞ –º–∞—Å–ª–µ –∏–ª–∏ –¥—Ä–∏—Ñ—Ç–µ
            if(onOil && Math.abs(this.speed) > 5) {
                if(Math.random()>0.5) particles.push({x:this.x, y:this.y, vx:0, vy:0, life:30, c:'rgba(20,20,20,0.5)', s:Math.random()*8+4});
            } else if (Math.abs(this.speed) > 15 && Math.abs(hX - moveX) > 0.5) {
                // –î—ã–º –æ—Ç —à–∏–Ω –ø—Ä–∏ –¥—Ä–∏—Ñ—Ç–µ
                particles.push({x:this.x, y:this.y, vx:0, vy:0, life:20, c:'rgba(200,200,200,0.3)', s:5});
            }

            // Bounds
            let mD = Infinity;
            for(let i=0; i<points.length; i++) {
                const p1=points[i], p2=points[(i+1)%points.length];
                const d = distToSeg(this, p1, p2); if(d<mD) mD=d;
            }
            if(mD > 450) { 
                this.speed *= 0.9;
                if(this.isPlayer && Math.abs(this.speed)>5) this.health-=0.2;
            }
            
            if(this.isPlayer) AudioEngine.update(this.speed);
        }

        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            
            // Industrial Style Car
            // Shadow
            ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(-16, -16, 36, 32);
            
            // Tires
            ctx.fillStyle='#111'; 
            ctx.fillRect(-14, -18, 12, 10); ctx.fillRect(-14, 8, 12, 10); // Rear
            ctx.fillRect(18, -18, 10, 10); ctx.fillRect(18, 8, 10, 10); // Front

            // Body
            ctx.fillStyle=this.color;
            roundRect(ctx, -16, -14, 32, 28, 4);
            
            // Detail
            ctx.fillStyle='#222'; ctx.fillRect(-10, -10, 20, 20); // Hood/Roof
            ctx.fillStyle='#111'; ctx.fillRect(0, -8, 8, 16); // Window
            
            // Bullbar / Bumper
            ctx.fillStyle='#555'; ctx.fillRect(16, -12, 4, 24);

            if(this.isPlayer) {
                ctx.fillStyle='#ffaa00'; ctx.fillRect(14, -12, 4, 6); ctx.fillRect(14, 6, 4, 6);
            }
            ctx.restore();
        }
    }

    // --- HELPERS ---
    function roundRect(ctx, x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r); ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y); ctx.fill(); }
    function distToSeg(p, v, w) { const l2=(v.x-w.x)**2+(v.y-w.y)**2; if(l2==0) return (p.x-v.x)**2+(p.y-v.y)**2; let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2; t=Math.max(0,Math.min(1,t)); return (p.x-(v.x+t*(w.x-v.x)))**2+(p.y-(v.y+t*(w.y-v.y)))**2; }

    // --- AUDIO ---
    const AudioEngine = {
        ctx: null, master: null, osc: null, gain: null,
        init: function() {
            try {
                if(this.ctx) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain(); this.master.gain.value = 0.2;
                this.master.connect(this.ctx.destination);
                this.osc = this.ctx.createOscillator(); this.osc.type = 'sawtooth';
                this.gain = this.ctx.createGain(); this.gain.gain.value = 0;
                this.osc.connect(this.gain); this.gain.connect(this.master);
                this.osc.start();
            } catch(e){}
        },
        update: function(speed) {
            if(!this.ctx) return;
            this.osc.frequency.setTargetAtTime(50 + Math.abs(speed)*6, this.ctx.currentTime, 0.1);
            this.gain.gain.setTargetAtTime(0.15, this.ctx.currentTime, 0.1);
        },
        play: function(key) {
            if(!this.ctx) return;
            const t = this.ctx.currentTime;
            const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
            o.connect(g); g.connect(this.master);
            if(key==='shoot'){ o.type='square'; o.frequency.setValueAtTime(200,t); o.frequency.exponentialRampToValueAtTime(50,t+0.2); g.gain.setValueAtTime(0.3,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.2); o.start(); o.stop(t+0.2); }
            if(key==='hit'){ o.type='sawtooth'; o.frequency.setValueAtTime(100,t); o.frequency.linearRampToValueAtTime(0,t+0.3); g.gain.setValueAtTime(0.5,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.3); o.start(); o.stop(t+0.3); }
        }
    };

    // --- GAME LOOP ---
    function update() {
        if(gameState!=='GAME') return;

        player.update();
        enemies.forEach((e, i) => {
            e.update();
            // Projectile
            for(let j=projectiles.length-1; j>=0; j--) {
                let p = projectiles[j];
                if((e.x-p.x)**2+(e.y-p.y)**2 < 2500) {
                    e.health-=100; projectiles.splice(j,1); AudioEngine.play('hit');
                    for(let k=0;k<10;k++) particles.push({x:e.x,y:e.y,vx:(Math.random()-0.5)*10,vy:(Math.random()-0.5)*10,life:30,c:'#e74c3c',s:6});
                }
            }
            if(e.health<=0) enemies.splice(i,1);
        });

        // Projectiles
        for(let i=projectiles.length-1; i>=0; i--) { let p=projectiles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; if(p.life<=0) projectiles.splice(i,1); }

        // Pickups
        for(let i=pickups.length-1; i>=0; i--) {
            let p=pickups[i];
            if((player.x-p.x)**2+(player.y-p.y)**2 < 4900) {
                if(p.type==='hp') player.health = Math.min(100, player.health+50);
                else player.ammo = Math.min(20, player.ammo+5);
                pickups.splice(i,1);
            }
        }

        // Camera Logic (Speed Zoom)
        let targetZoom = 0.7 - (Math.abs(player.speed) / PHYS.maxSpeed) * 0.15;
        cam.zoom += (targetZoom - cam.zoom) * 0.05;
        cam.x += (player.x - cam.x) * 0.1; 
        cam.y += (player.y - cam.y) * 0.1;

        // Laps
        let ncp = (nextCP+1)%points.length;
        if((player.x-points[ncp].x)**2+(player.y-points[ncp].y)**2 < 200000) {
            nextCP=ncp; 
            if(nextCP===0) {
                laps++; 
                spawnLoot(); spawnOil();
                enemies.push(new Car(points[0].x, points[0].y, false));
            }
        }

        if(player.health<=0) gameOver();

        // Particles
        particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.life--; });
        particles = particles.filter(p=>p.life>0);

        // HUD
        document.getElementById('lap-counter').innerText = laps+1;
        document.getElementById('hp-fill').style.width = player.health+'%';
        document.getElementById('speed-text').innerText = Math.round(player.speed * 3) + ' KM/H';
    }

    function draw() {
        if(gameState==='MENU') { ctx.fillStyle='#111'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
        
        ctx.fillStyle='#1a1a1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(cam.zoom, cam.zoom);
        ctx.translate(-cam.x, -cam.y);

        // Decor (Rusty Plates)
        ctx.fillStyle='#252525';
        points.forEach(p => ctx.fillRect(p.x-1000, p.y-1000, 600, 600));

        // Road
        ctx.lineCap='round'; ctx.lineJoin='round';
        ctx.lineWidth=950; ctx.strokeStyle='#b33939'; 
        ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let p of points) ctx.lineTo(p.x, p.y); ctx.closePath(); ctx.stroke();
        
        ctx.lineWidth=900; ctx.strokeStyle='#444'; ctx.stroke(); // Asphalt
        
        ctx.lineWidth=6; ctx.strokeStyle='#777'; ctx.setLineDash([100,200]); ctx.stroke(); ctx.setLineDash([]);

        oils.forEach(o => o.draw(ctx));
        pickups.forEach(p => { 
            ctx.fillStyle=p.type==='hp'?'#2ecc71':'#f1c40f'; 
            ctx.beginPath(); ctx.arc(p.x,p.y,20,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle='#000'; ctx.font='bold 24px monospace'; ctx.fillText(p.type==='hp'?'+':'!', p.x-8, p.y+8);
        });
        projectiles.forEach(p => { ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill(); });
        enemies.forEach(e => e.draw(ctx));
        player.draw(ctx);
        particles.forEach(p => { ctx.fillStyle=p.c; ctx.fillRect(p.x, p.y, p.s, p.s); });

        ctx.restore();
    }

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');
        
        AudioEngine.init();
        if(AudioEngine.ctx && AudioEngine.ctx.state==='suspended') AudioEngine.ctx.resume();

        gameState = 'GAME';
        laps=0; nextCP=0;
        player = new Car(points[0].x, points[0].y, true);
        cam.x = player.x; cam.y = player.y;
        enemies=[]; 
        enemies.push(new Car(points[0].x+200, points[0].y+200, false));
        pickups=[]; projectiles=[]; oils=[];
        spawnLoot(); spawnOil(); spawnOil();
    }

    function spawnLoot() {
        ['hp','ammo'].forEach(t => {
            let i = Math.floor(Math.random()*points.length);
            let p1=points[i], p2=points[(i+1)%points.length];
            pickups.push({x:(p1.x+p2.x)/2 + (Math.random()-0.5)*500, y:(p1.y+p2.y)/2 + (Math.random()-0.5)*500, type:t});
        });
    }

    function spawnOil() {
        let i = Math.floor(Math.random()*points.length);
        let p1=points[i], p2=points[(i+1)%points.length];
        oils.push(new OilSlick((p1.x+p2.x)/2 + (Math.random()-0.5)*600, (p1.y+p2.y)/2 + (Math.random()-0.5)*600, 150));
    }

    function gameOver() {
        gameState = 'OVER';
        document.getElementById('final-score').innerText = laps;
        document.getElementById('gameover-screen').classList.remove('hidden');
        if(lb) lb.setLeaderboardScore('laps', laps);
        if(ysdk) ysdk.adv.showFullscreenAdv({callbacks:{}});
    }

    // Input
    function bind(id, k) {
        const b=document.getElementById(id);
        const s=(v)=>{keys[k]=v; v?b.style.borderColor='#fff':b.style.borderColor='rgba(0,0,0,0)';};
        b.addEventListener('touchstart', e=>{e.preventDefault();s(true)},{passive:false});
        b.addEventListener('touchend', e=>{e.preventDefault();s(false)},{passive:false});
        b.addEventListener('mousedown', ()=>s(true)); b.addEventListener('mouseup', ()=>s(false));
    }
    bind('b-gas','up'); bind('b-shoot','shoot'); bind('b-left','left'); bind('b-right','right');

    window.onkeydown=e=>{
        if(e.code=='ArrowUp')keys.up=true;
        if(e.code=='ArrowDown'||e.code=='Space')keys.shoot=true;
        if(e.code=='ArrowLeft')keys.left=true;if(e.code=='ArrowRight')keys.right=true;
    };
    window.onkeyup=e=>{
        if(e.code=='ArrowUp')keys.up=false;
        if(e.code=='ArrowDown'||e.code=='Space')keys.shoot=false;
        if(e.code=='ArrowLeft')keys.left=false;if(e.code=='ArrowRight')keys.right=false;
    };

    function loop() { requestAnimationFrame(loop); update(); draw(); }
    loop();
</script>
</body>
</html>
