
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Night Mall: Combat Fixed</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: #cda; 
            font-family: 'Courier New', monospace; touch-action: none; 
            display: flex; flex-direction: column; height: 100vh; 
            user-select: none; -webkit-user-select: none;
        }

        /* FILTER */
        body::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 200;
            background-image: radial-gradient(circle at center, transparent 40%, rgba(160, 140, 120, 0.2) 100%);
            mix-blend-mode: multiply;
        }

        #game-wrapper {
            position: relative; width: 100%; height: 60vh;
            background: #e0d8c0; 
            border-bottom: 3px solid #a98;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 15px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between; z-index: 10;
        }
        .hud-top { display: flex; gap: 10px; }
        .stat-badge {
            background: rgba(255,255,255,0.8); padding: 5px 12px; border-radius: 20px;
            font-weight: 900; color: #555; font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); border: 1px solid #fff;
        }
        .hp-txt { color: #d00; } .ammo-txt { color: #d80; }

        #center-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fff; padding: 15px 30px; border-radius: 30px;
            font-weight: 900; font-size: 20px; color: #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); opacity: 0; transition: opacity 0.3s;
            text-transform: uppercase; white-space: nowrap;
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #d8ceb8; z-index: 300; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        .btn-start {
            background: #f0e0d0; color: #543; border: 3px solid #543;
            padding: 20px 50px; font-size: 20px; font-weight: 900;
            cursor: pointer; text-transform: uppercase; letter-spacing: 3px;
            box-shadow: 6px 6px 0 #876; border-radius: 12px;
            transition: transform 0.1s;
        }
        .btn-start:active { transform: scale(0.95); box-shadow: 2px 2px 0 #876; }

        #controller {
            flex: 1; background: #cdc0b0; position: relative;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 40px; z-index: 150; border-top: 2px solid #fff;
        }
        
        .dpad { position: relative; width: 140px; height: 140px; }
        .d-bg { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 140px; height: 140px; border-radius: 50%; background: #bda;
            border: 4px solid #9a8; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1);
        }
        .d-btn {
            position: absolute; width: 50px; height: 50px; cursor: pointer; z-index: 20;
            display: flex; justify-content: center; align-items: center; font-size: 28px; color: #765;
        }
        .d-btn:active { color: #321; transform: scale(0.9); }
        .u { top: 0; left: 45px; } .d { bottom: 0; left: 45px; }
        .l { top: 45px; left: 0; } .r { top: 45px; right: 0; }

        .actions { position: relative; width: 120px; height: 120px; transform: rotate(-15deg); }
        .btn {
            position: absolute; width: 45px; height: 45px; border-radius: 50%;
            background: #e0d0c0; border: 3px solid #987; box-shadow: 3px 3px 0 #765;
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; font-weight: 900; color: #543; cursor: pointer;
        }
        .btn:active { transform: scale(0.9); background: #d0c0b0; box-shadow: none; }
        .b-y { top: 40px; left: 0; }
        .b-b { bottom: 0; left: 40px; }
        .b-a { top: 40px; right: 0; }
        .b-x { top: 0; left: 40px; }

    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-badge">ЭТАЖ <span id="ui-fl">1</span></div>
            <div class="stat-badge hp-txt">HP <span id="ui-hp">100</span></div>
            <div class="stat-badge ammo-txt">ВЕЩИ <span id="ui-ammo">2</span></div>
        </div>
        <div id="center-msg"></div>
    </div>
    <div id="overlay">
        <h1 style="color:#543; margin-bottom:10px; letter-spacing: 5px;">MALL MAZE</h1>
        <p style="color:#765; margin-bottom:30px; font-size:12px;">v14.0 FIXED COMBAT</p>
        <button class="btn-start" onclick="initSystem()">СТАРТ</button>
    </div>
</div>

<div id="controller">
    <div class="dpad">
        <div class="d-bg"></div>
        <div class="d-btn u" onmousedown="input('up')" ontouchstart="input('up', event)">▲</div>
        <div class="d-btn d" onmousedown="input('down')" ontouchstart="input('down', event)">▼</div>
        <div class="d-btn l" onmousedown="input('left')" ontouchstart="input('left', event)">◄</div>
        <div class="d-btn r" onmousedown="input('right')" ontouchstart="input('right', event)">►</div>
    </div>
    <div class="actions">
        <div class="btn b-x" onclick="action('WAIT')">ЖДАТЬ</div>
        <div class="btn b-a" onclick="action('HIT')">УДАР</div>
        <div class="btn b-b" onclick="action('THROW')">БРОС</div>
        <div class="btn b-y" onclick="action('SEARCH')">ВЗЯТЬ</div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
    // === НАСТРОЙКИ ===
    const CFG = { TILE: 10, SPEED: 280 };
    const state = { fl: 1, hp: 100, ammo: 2, busy: false, over: false };
    const player = { x: 1, z: 1, dir: 1 };
    
    let scene, camera, renderer, lvlGroup;
    let enemies = [], secrets = [], map = [];
    let audioCtx, reverbNode, droneOsc;
    let texAtlas, texFloor, materialsCache = {};

    // --- 1. ТЕКСТУРЫ ---
    function generateShopAtlas() {
        const cvs = document.createElement('canvas');
        cvs.width = 1024; cvs.height = 1024;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#222'; ctx.fillRect(0,0,1024,1024);
        const rows = 3; const cols = 4;
        const w = 1024/cols; const h = 1024/rows;
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                const x = c*w; const y = r*h;
                ctx.fillStyle = '#e0e0e0'; ctx.fillRect(x+5, y+5, w-10, h-10);
                const grad = ctx.createLinearGradient(x, y, x, y+h);
                if(r===2) { 
                    grad.addColorStop(0, '#543'); grad.addColorStop(1, '#864'); ctx.fillStyle = grad; ctx.fillRect(x+15, y+15, w-30, h-30);
                    ctx.fillStyle = '#a86'; ctx.fillRect(x+20, y+80, w-40, 10);
                } else if (r===1) {
                    grad.addColorStop(0, '#ccc'); grad.addColorStop(1, '#fff'); ctx.fillStyle = grad; ctx.fillRect(x+15, y+15, w-30, h-30);
                    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(x+w/2, y+h/2, 20, 0, Math.PI*2); ctx.fill();
                } else {
                    grad.addColorStop(0, '#112'); grad.addColorStop(1, '#224'); ctx.fillStyle = grad; ctx.fillRect(x+15, y+15, w-30, h-30);
                    ctx.fillStyle = (c%2===0)?'#0ff':'#f0f'; ctx.fillRect(x+40, y+60, w-80, 50);
                }
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(x+w, y); ctx.lineTo(x, y+h); ctx.stroke();
            }
        }
        const t = new THREE.CanvasTexture(cvs); t.encoding = THREE.sRGBEncoding; return t;
    }

    function generateFloorTex() {
        const c = document.createElement('canvas'); c.width=512; c.height=512;
        const x = c.getContext('2d');
        x.fillStyle='#f5f0e0'; x.fillRect(0,0,512,512);
        x.strokeStyle='#d8d0c0'; x.lineWidth=2;
        x.beginPath(); for(let i=0;i<=512;i+=128){x.moveTo(i,0);x.lineTo(i,512);x.moveTo(0,i);x.lineTo(512,i);} x.stroke();
        const t = new THREE.CanvasTexture(c); t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping; return t;
    }

    // --- 2. ИНИЦИАЛИЗАЦИЯ ---
    function initSystem() {
        document.getElementById('overlay').style.display = 'none';
        initAudio();
        texAtlas = generateShopAtlas();
        texFloor = generateFloorTex();
        prewarmMaterials();
        initThree();
    }

    function prewarmMaterials() {
        const rows = 3; const cols = 4;
        const colW = 1/cols; const rowH = 1/rows;
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                const mat = new THREE.MeshStandardMaterial({ map: texAtlas.clone(), roughness: 0.2, metalness: 0.1 });
                mat.map.needsUpdate = true;
                mat.map.repeat.set(colW, rowH);
                mat.map.offset.x = c * colW;
                mat.map.offset.y = (rows - 1 - r) * rowH;
                materialsCache[`${r}_${c}`] = mat;
            }
        }
    }

    function initAudio() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        const len = audioCtx.sampleRate * 2.0;
        const buf = audioCtx.createBuffer(2, len, audioCtx.sampleRate);
        for(let c=0;c<2;c++) { const d=buf.getChannelData(c); for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/len, 2); }
        reverbNode = audioCtx.createConvolver(); reverbNode.buffer = buf; reverbNode.connect(audioCtx.destination);
        droneOsc = audioCtx.createOscillator(); droneOsc.type = 'sine'; droneOsc.frequency.value = 60;
        const g = audioCtx.createGain(); g.gain.value = 0.1; droneOsc.connect(g); g.connect(reverbNode); droneOsc.start();
    }

    function sfx(t) {
        if(!audioCtx) return;
        const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.connect(g); g.connect(reverbNode);
        const n=audioCtx.currentTime;
        if(t==='step'){ o.frequency.setValueAtTime(120,n); o.frequency.exponentialRampToValueAtTime(20,n+0.15); g.gain.setValueAtTime(0.3,n); g.gain.linearRampToValueAtTime(0,n+0.15); o.start(n); o.stop(n+0.15); }
        else if(t==='hit'){ o.type='sawtooth'; o.frequency.setValueAtTime(150,n); o.frequency.exponentialRampToValueAtTime(50,n+0.3); g.gain.setValueAtTime(0.5,n); g.gain.linearRampToValueAtTime(0,n+0.3); o.start(n); o.stop(n+0.3); haptic(80); }
        else if(t==='ui'){ o.type='triangle'; o.frequency.setValueAtTime(800,n); g.gain.setValueAtTime(0.1,n); g.gain.linearRampToValueAtTime(0,n+0.05); o.start(n); o.stop(n+0.05); }
        else if(t==='get'){ o.type='sine'; o.frequency.setValueAtTime(1000,n); o.frequency.linearRampToValueAtTime(2000,n+0.4); g.gain.setValueAtTime(0.2,n); g.gain.linearRampToValueAtTime(0,n+0.4); o.start(n); o.stop(n+0.4); haptic([30,50,30]); }
    }
    function haptic(p) { if(navigator.vibrate) navigator.vibrate(p); }

    function initThree() {
        const wrap = document.getElementById('game-wrapper');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0xe0d8c0); scene.fog = new THREE.FogExp2(0xe0d8c0, 0.035);
        camera = new THREE.PerspectiveCamera(90, wrap.clientWidth/wrap.clientHeight, 0.1, 100);
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(wrap.clientWidth, wrap.clientHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.1;
        wrap.appendChild(renderer.domElement);
        const amb = new THREE.AmbientLight(0xfff0e0, 0.8); scene.add(amb);
        const pl = new THREE.PointLight(0xffeedd, 0.8, 30); pl.position.set(0,2,0); camera.add(pl); scene.add(camera);
        lvlGroup = new THREE.Group(); scene.add(lvlGroup);
        loadLevel(1); render();
        window.onresize = () => { camera.aspect=wrap.clientWidth/wrap.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(wrap.clientWidth, wrap.clientHeight); };
    }

    // --- 3. ЛОГИКА ---
    const levels = [
        [[1,1,1,1,1,1,1],[1,9,0,0,1,5,1],[1,1,1,0,0,0,1],[1,5,0,0,2,0,1],[1,8,0,0,0,0,1],[1,1,1,1,1,1,1]],
        [[1,1,1,1,1,1],[1,9,0,5,2,1],[1,0,1,1,0,1],[1,0,2,0,0,1],[1,0,1,1,8,1],[1,1,1,1,1,1]],
        [[1,1,1,1,1,1,1,1],[1,9,0,2,0,0,5,1],[1,0,1,1,1,1,0,1],[1,0,0,2,2,0,0,1],[1,1,1,0,1,1,8,1],[1,1,1,1,1,1,1,1]]
    ];

    function loadLevel(n) {
        state.fl = n; if(n > levels.length) { gameOver(true); return; }
        while(lvlGroup.children.length) lvlGroup.remove(lvlGroup.children[0]);
        enemies=[]; secrets=[]; map=JSON.parse(JSON.stringify(levels[n-1]));
        const matFl = new THREE.MeshStandardMaterial({ map: texFloor, roughness: 0.5 });
        const geoBox = new THREE.BoxGeometry(CFG.TILE, CFG.TILE, CFG.TILE);
        const geoPlane = new THREE.PlaneGeometry(CFG.TILE, CFG.TILE);

        for(let z=0; z<map.length; z++) {
            for(let x=0; x<map[z].length; x++) {
                const v = map[z][x];
                const f = new THREE.Mesh(geoPlane, matFl); f.rotation.x=-Math.PI/2; f.position.set(x*10,-5,z*10); lvlGroup.add(f);
                const c = new THREE.Mesh(geoPlane, new THREE.MeshBasicMaterial({color:0xffffff})); c.rotation.x=Math.PI/2; c.position.set(x*10,5,z*10); lvlGroup.add(c);
                if(v===1) {
                    const r = 3 - n; const cIdx = Math.floor(Math.random()*4);
                    const w = new THREE.Mesh(geoBox, materialsCache[`${r}_${cIdx}`] || new THREE.MeshBasicMaterial({color:0x888}));
                    w.position.set(x*10,0,z*10); lvlGroup.add(w);
                } 
                else if(v===5) {
                    const cr = new THREE.Mesh(new THREE.OctahedronGeometry(2), new THREE.MeshPhongMaterial({color:0xff00ff, emissive:0xff00ff}));
                    cr.position.set(x*10,0,z*10); cr.add(new THREE.PointLight(0xff00ff, 1, 10)); lvlGroup.add(cr); secrets.push({x,z,mesh:cr});
                }
                else if(v===9) { player.x=x; player.z=z; player.dir=1; map[z][x]=0; }
                else if(v===8) { const ex=new THREE.Mesh(new THREE.BoxGeometry(10,10,1), new THREE.MeshBasicMaterial({color:0x5f5})); ex.position.set(x*10,0,z*10); lvlGroup.add(ex); }
                else if(v===2) { spawnEnemy(x,z); map[z][x]=0; }
            }
        }
        updateCam(true); updateUI(); msg("ЭТАЖ "+n);
    }

    function spawnEnemy(x,z) {
        const g=new THREE.Group();
        const core=new THREE.Mesh(new THREE.DodecahedronGeometry(3), new THREE.MeshStandardMaterial({color:0x888, transparent:true, opacity:0.6}));
        const aura=new THREE.Mesh(new THREE.DodecahedronGeometry(3.2), new THREE.MeshBasicMaterial({color:0xd33, wireframe:true}));
        g.add(core); g.add(aura); g.position.set(x*10,0,z*10); lvlGroup.add(g); enemies.push({x,z,mesh:g,hp:2,alive:true});
    }

    // --- УПРАВЛЕНИЕ И БОЙ (ИСПРАВЛЕНО) ---
    window.input = function(cmd, e) {
        if(e) e.preventDefault();
        if(state.busy || state.over || !audioCtx) return;
        sfx('ui');
        let moved = false;
        if(cmd === 'left') rotate(-1);
        else if(cmd === 'right') rotate(1);
        else if(cmd === 'up') moved = move(1);
        else if(cmd === 'down') moved = move(-1);
        if(moved) turn();
    };

    window.action = function(act) {
        if(state.busy || state.over || !audioCtx) return;
        if(act === 'WAIT') { msg("..."); turn(); }
        else if(act === 'HIT') {
            // ЛОГИКА УДАРА ВОЗВРАЩЕНА
            const t = getFront(1);
            if(dmgEn(t.x, t.z, 1)) { punch(); turn(); }
            else { msg("МИМО"); shake(0.2); }
        } 
        else if(act === 'SEARCH') checkItem(true); 
        else if(act === 'THROW') {
            // ЛОГИКА БРОСКА ВОЗВРАЩЕНА
            if(state.ammo > 0) { 
                state.ammo--; updateUI();
                let hit = false;
                for(let i=1; i<=3; i++) {
                    const t = getFront(i);
                    if(map[t.z][t.x] === 1) break; // Стена
                    if(dmgEn(t.x, t.z, 2)) { hit = true; break; }
                }
                msg(hit ? "ПОПАЛ!" : "ПРОМАХ"); 
                punch(); turn(); 
            }
            else msg("ПУСТО");
        }
    };

    function rotate(d) {
        state.busy = true; player.dir += d;
        if(player.dir > 3) player.dir = 0; if(player.dir < 0) player.dir = 3;
        updateCam(); setTimeout(() => state.busy = false, 200);
    }

    function move(s) {
        const tg = getFront(s);
        if(map[tg.z][tg.x] === 1) { msg("ЗАКРЫТО"); return false; }
        if(enemies.some(e=>e.alive && e.x===tg.x && e.z===tg.z)){ msg("ТЕНЬ!"); shake(0.3); return false; }
        if(map[tg.z][tg.x] === 8) { loadLevel(state.fl + 1); return false; }
        
        state.busy = true; player.x = tg.x; player.z = tg.z; sfx('step'); haptic(10);
        checkItem(false); 
        new TWEEN.Tween(camera.position).to({y: -0.5}, 140).yoyo(true).repeat(1).start();
        updateCam(); setTimeout(() => state.busy = false, 280);
        return true;
    }

    function dmgEn(x, z, dmg) {
        const e = enemies.find(e => e.alive && e.x === x && e.z === z);
        if(e) {
            e.hp -= dmg;
            sfx('hit');
            e.mesh.children[0].material.color.setHex(0xffffff); // Flash white
            setTimeout(() => e.mesh.children[0].material.color.setHex(0x888888), 150);
            if(e.hp <= 0) {
                e.alive = false; e.mesh.visible = false; msg("УБИТ");
            }
            return true;
        }
        return false;
    }

    function checkItem(manual) {
        if(map[player.z][player.x] === 5) {
            map[player.z][player.x] = 0;
            const s = secrets.find(i => i.x === player.x && i.z === player.z);
            if(s) s.mesh.visible = false;
            state.ammo += 2; updateUI(); sfx('get'); msg("НАШЕЛ!");
        } else if(manual) msg("ПУСТО");
    }

    function getFront(d) {
        let dx=0, dz=0;
        if(player.dir===0) dz=-d; if(player.dir===1) dx=d; if(player.dir===2) dz=d; if(player.dir===3) dx=-d;
        return { x: player.x+dx, z: player.z+dz };
    }

    function turn() {
        state.busy = true;
        setTimeout(() => {
            enemies.forEach(e => {
                if(!e.alive) return;
                const dst = Math.abs(player.x - e.x) + Math.abs(player.z - e.z);
                
                // Атака игрока
                if(dst <= 1) {
                    state.hp -= 15; updateUI(); msg("УРОН -15"); shake(0.5); haptic(100); sfx('hit');
                    if(state.hp <= 0) gameOver(false);
                } 
                // Движение к игроку
                else if(dst < 6) {
                    let nx=e.x, nz=e.z;
                    // Простая попытка движения по осям
                    if(Math.abs(player.x - e.x) > Math.abs(player.z - e.z)) {
                        const tx = e.x + Math.sign(player.x - e.x);
                        if(map[e.z][tx] !== 1) nx = tx; // Если по X свободно
                        else nz = e.z + Math.sign(player.z - e.z); // Иначе пробуем Z
                    } else {
                        const tz = e.z + Math.sign(player.z - e.z);
                        if(map[tz][e.x] !== 1) nz = tz; // Если по Z свободно
                        else nx = e.x + Math.sign(player.x - e.x); // Иначе пробуем X
                    }

                    // Проверка коллизий с другими врагами и игроком
                    if(!enemies.some(o => o!==e && o.alive && o.x===nx && o.z===nz) && !(nx===player.x && nz===player.z)) {
                        if(map[nz][nx] !== 1) { // Финальная проверка стены
                            new TWEEN.Tween(e.mesh.position).to({x: nx*10, z: nz*10}, 300).start();
                            e.x = nx; e.z = nz;
                        }
                    }
                }
            });
            state.busy = false;
        }, 300);
    }

    function updateCam(i) {
        const tx=player.x*10, tz=player.z*10;
        let ry=0; if(player.dir===1)ry=-Math.PI/2; if(player.dir===2)ry=-Math.PI; if(player.dir===3)ry=-Math.PI*1.5;
        if(i) { camera.position.set(tx,0,tz); camera.rotation.set(0,ry,0); }
        else { new TWEEN.Tween(camera.position).to({x:tx,z:tz},280).start(); new TWEEN.Tween(camera.rotation).to({y:ry},280).start(); }
    }

    function msg(t) { const el=document.getElementById('center-msg'); el.innerText=t; el.style.opacity=1; setTimeout(()=>el.style.opacity=0,1000); }
    function updateUI() { document.getElementById('ui-fl').innerText=state.fl; document.getElementById('ui-hp').innerText=state.hp; document.getElementById('ui-ammo').innerText=state.ammo; }
    function render(t) { requestAnimationFrame(render); TWEEN.update(t); secrets.forEach(s=>{if(s.mesh.visible)s.mesh.rotation.y+=0.02;}); renderer.render(scene,camera); }
    function gameOver(w) { state.over=true; document.getElementById('overlay').style.display='flex'; document.querySelector('#overlay h1').innerText=w?"СВОБОДА!":"ТЬМА..."; droneOsc.stop(); }
    function shake(p) { new TWEEN.Tween(camera.position).to({x:camera.position.x+p},50).yoyo(true).repeat(3).start(); }
    function punch() { new TWEEN.Tween(camera.position).to({z:camera.position.z-Math.cos(camera.rotation.y)*0.5,x:camera.position.x-Math.sin(camera.rotation.y)*0.5},50).yoyo(true).repeat(1).start(); haptic(40); }

    document.addEventListener('keydown', e=>{const k=e.key.toLowerCase(); if(k==='w')input('up'); if(k==='s')input('down'); if(k==='a')input('left'); if(k==='d')input('right'); if(k==='e')action('SEARCH');});
</script>
</body>
</html>
