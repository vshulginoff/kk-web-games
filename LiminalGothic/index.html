<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Liminal Gothic: Лабиринт Снов</title>
    
    <script src="https://yandex.ru/games/sdk/v2"></script>
    
    <script src="three.min.js"></script>

    <style>
        html, body { 
            width: 100%; height: 100%; margin: 0; padding: 0; 
            overflow: hidden; background: #000; 
            font-family: 'Courier New', monospace; color: #d0a0a0;
            touch-action: none; /* Запрет жестов браузера */
            user-select: none; -webkit-user-select: none; /* Запрет выделения */
            -webkit-touch-callout: none; /* Запрет меню iOS */
        }

        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* ИНТЕРФЕЙС */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 10; pointer-events: none; display: none;
        }
        
        .hud-top {
            position: absolute; top: max(15px, env(safe-area-inset-top)); 
            left: max(15px, env(safe-area-inset-left)); 
            right: max(15px, env(safe-area-inset-right));
            display: flex; justify-content: space-between;
            font-size: 18px; font-weight: bold;
            text-shadow: 2px 2px 4px #000; pointer-events: none;
        }
        .hud-score { color: #ffbd77; }

        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 150%);
            z-index: 5; opacity: 0.8; pointer-events: none;
        }

        /* ДЖОЙСТИК */
        #joystick-container {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            width: 180px; height: 180px; pointer-events: auto; z-index: 100;
        }
        #joystick-base {
            width: 100%; height: 100%; background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; position: relative; backdrop-filter: blur(2px);
        }
        #joystick-knob {
            width: 70px; height: 70px; background: rgba(200, 180, 180, 0.6);
            border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255,255,255,0.4); pointer-events: none;
        }

        /* МЕНЮ */
        .full-screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 10, 15, 0.98); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; pointer-events: auto;
        }
        h1 { margin: 0 0 10px 0; font-size: 28px; color: #d65d5d; letter-spacing: 2px; text-shadow: 0 0 15px #500; padding: 0 20px; }
        
        .blink { 
            animation: blink 2s infinite ease-in-out; 
            color: #fff; cursor: pointer; 
            margin-top: 20px; font-size: 20px; 
            text-decoration: underline; padding: 20px; 
            border: 1px solid #444; background: rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        @keyframes blink { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }

        #leaderboard {
            margin-top: 20px; padding: 15px; border: 1px solid #553333;
            background: rgba(0,0,0,0.5); width: 280px; min-height: 100px;
        }
        #score-list { list-style: none; padding: 0; margin: 0; font-size: 14px; color: #aaa; text-align: left; }
        #score-list li { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 2px;}
        #score-list span { color: #d65d5d; }

        #game-over-screen { display: none; background: rgba(50, 0, 0, 0.9); }
        .big-score { font-size: 50px; color: #fff; margin: 10px 0; text-shadow: 0 0 20px red; }
        #status-text { font-size: 10px; margin-top: 10px; color: #555; }
    </style>
</head>
<body>

<div id="start-screen" class="full-screen-overlay">
    <h1 id="title-text">Liminal Gothic: Лабиринт Снов</h1>
    <div id="leaderboard">
        <h3 id="lb-title" style="color:#888; margin:0 0 10px 0; border-bottom:1px solid #555;">РЕКОРДЫ</h3>
        <ul id="score-list"><li>...</li></ul>
    </div>
    <div class="blink" id="start-btn">[ НАЖМИ СТАРТ ]</div>
    <div id="status-text">...</div>
</div>

<div id="game-over-screen" class="full-screen-overlay">
    <h1 style="color: #fff;" id="died-text">ВЫ ПОГИБЛИ</h1>
    <p id="score-text">СЧЕТ</p>
    <div class="big-score" id="final-score">0</div>
    <div class="blink" id="restart-btn">[ МЕНЮ ]</div>
</div>

<div id="game-container"></div>

<div id="ui-layer">
    <div id="vignette"></div>
    <div class="hud-top">
        <div><span id="txt-lvl">LVL</span>: <span id="ui-level">1</span></div>
        <div class="hud-score"><span id="txt-pts">PTS</span>: <span id="ui-score">0</span></div>
        <div>HP: <span id="ui-lives">3</span></div>
    </div>
    <div id="joystick-container">
        <div id="joystick-base"><div id="joystick-knob"></div></div>
    </div>
</div>

<script>
// --- БЛОКИРОВКА КОНТЕКСТНОГО МЕНЮ (Требование 1.6.2.7) ---
document.addEventListener('contextmenu', event => event.preventDefault());

// --- ЛОКАЛИЗАЦИЯ (Требование 8.2.3) ---
const LANGS = {
    ru: {
        title: "Liminal Gothic: Лабиринт Снов",
        lbTitle: "РЕКОРДЫ",
        start: "[ НАЖМИ СТАРТ ]",
        died: "ВЫ ПОГИБЛИ",
        final: "СЧЕТ",
        menu: "[ МЕНЮ ]",
        lvl: "УР",
        pts: "ОЧК"
    },
    en: {
        title: "Liminal Gothic: Dream Maze",
        lbTitle: "LEADERBOARD",
        start: "[ TAP TO START ]",
        died: "YOU DIED",
        final: "SCORE",
        menu: "[ MENU ]",
        lvl: "LVL",
        pts: "PTS"
    }
};
let currentLang = 'en'; // По умолчанию

function applyLang(lang) {
    const t = LANGS[lang] || LANGS.en;
    document.title = t.title;
    document.getElementById('title-text').innerText = t.title;
    document.getElementById('lb-title').innerText = t.lbTitle;
    document.getElementById('start-btn').innerText = t.start;
    document.getElementById('died-text').innerText = t.died;
    document.getElementById('score-text').innerText = t.final;
    document.getElementById('restart-btn').innerText = t.menu;
    document.getElementById('txt-lvl').innerText = t.lvl;
    document.getElementById('txt-pts').innerText = t.pts;
    currentLang = lang;
}

// --- ПРОВЕРКА ДВИЖКА ---
if (typeof THREE === 'undefined') {
    document.body.innerHTML = "<h1 style='color:red;text-align:center;margin-top:50px'>ERROR: three.min.js missing</h1>";
    throw new Error("Three.js missing");
}

// --- SDK SYSTEM ---
let ysdk = null;
let lb = null;
let isLocalMode = false;
const LB_NAME = 'Leaderboard1'; 

function renderList(type, data) {
    const list = document.getElementById('score-list');
    const status = document.getElementById('status-text');
    list.innerHTML = '';
    
    if (type === 'yandex' && data.entries.length > 0) {
        status.innerHTML = '<span style="color:#0f0">Online</span>';
        data.entries.forEach(entry => {
            list.innerHTML += `<li>${entry.rank}. ${entry.player.publicName} <span>${entry.score}</span></li>`;
        });
    } else if (type === 'local') {
        status.innerHTML = '<span style="color:#fa0">Local</span>';
        const localScores = JSON.parse(localStorage.getItem('gothic_scores_v3') || '[0,0,0]');
        localScores.forEach((s, i) => { if(s>0) list.innerHTML += `<li>#${i+1} Local <span>${s}</span></li>`; });
        if(list.innerHTML === '') list.innerHTML = '<li>---</li>';
    } else {
        if(type === 'yandex') status.innerHTML = '<span style="color:#0f0">Online (Empty)</span>';
        list.innerHTML = '<li>...</li>';
    }
}

function initPlatform() {
    // Фаллбек таймер
    setTimeout(() => {
        if(!ysdk && !isLocalMode) {
            isLocalMode = true;
            applyLang('ru'); // Фаллбек язык
            renderList('local');
        }
    }, 3000);

    if (window.YaGames) {
        YaGames.init()
            .then(_ysdk => {
                ysdk = _ysdk;
                
                // Автоопределение языка (Требование SDK)
                const langCode = ysdk.environment.i18n.lang;
                applyLang(langCode === 'ru' || langCode === 'be' || langCode === 'kk' || langCode === 'uk' ? 'ru' : 'en');

                // Game Ready API (Требование 1.14 / Game Ready)
                ysdk.features.LoadingAPI.ready();

                return ysdk.getLeaderboards();
            })
            .then(_lb => {
                lb = _lb;
                return lb.getLeaderboardEntries(LB_NAME, { quantity: 5, includeUser: true });
            })
            .then(res => renderList('yandex', res))
            .catch(err => {
                console.error("SDK Error:", err);
                isLocalMode = true;
                applyLang('ru'); // Если ошибка, ставим RU
                renderList('local');
            });
    } else {
        isLocalMode = true;
        applyLang('ru');
        renderList('local');
    }
}

function refreshLeaderboard() {
    if (isLocalMode || !lb) { renderList('local'); return; }
    document.getElementById('score-list').innerHTML = '<li>...</li>';
    lb.getLeaderboardEntries(LB_NAME, { quantity: 5, includeUser: true })
        .then(res => renderList('yandex', res))
        .catch(() => renderList('local'));
}

function saveScorePlatform(score) {
    let localScores = JSON.parse(localStorage.getItem('gothic_scores_v3') || '[]');
    localScores.push(score); localScores.sort((a,b)=>b-a); localScores=localScores.slice(0,5);
    localStorage.setItem('gothic_scores_v3', JSON.stringify(localScores));

    if (ysdk && lb && !isLocalMode) {
        lb.setLeaderboardScore(LB_NAME, score).catch(e=>console.log(e));
    }
}

function showAd(callback) {
    if (ysdk && !isLocalMode) {
        ysdk.adv.showFullscreenAdv({
            callbacks: { onClose: callback, onError: callback }
        });
    } else {
        callback();
    }
}

initPlatform();

// --- УПРАВЛЕНИЕ ЗВУКОМ (Требование 1.3) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let audioReady = false; let musicInterval = null;

// Пауза звука при сворачивании
document.addEventListener('visibilitychange', () => {
    if (audioCtx.state !== 'closed') {
        if (document.hidden) {
            audioCtx.suspend();
        } else {
            audioCtx.resume();
        }
    }
});

// --- GAME LOGIC ---
const CONFIG = { blockSize: 4, baseMoveSpeed: 0.13, rotSpeed: 0.05, baseGhostSpeed: 0.048, powerDuration: 8000 };
const gameState = { score: 0, lives: 3, level: 1, playing: false, powerMode: false, dotsLeft: 0 };
const ui = {
    score: document.getElementById('ui-score'), lives: document.getElementById('ui-lives'),
    level: document.getElementById('ui-level'), startScreen: document.getElementById('start-screen'),
    gameOverScreen: document.getElementById('game-over-screen'), gameUI: document.getElementById('ui-layer'),
    finalScore: document.getElementById('final-score'), joyBase: document.getElementById('joystick-base'),
    joyKnob: document.getElementById('joystick-knob')
};

function sfx(freq, type, dur, vol) {
    if(!audioReady || audioCtx.state!=='running') return;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type=type; o.frequency.value=freq;
    g.gain.setValueAtTime(vol, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime+dur);
    o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur);
}

function startMusic() {
    if(musicInterval) clearInterval(musicInterval);
    let idx = 0; const notes = [65.41, 98.00, 130.81, 155.56];
    musicInterval = setInterval(() => {
        if(!gameState.playing && ui.startScreen.style.display!=='none') return;
        const f = notes[idx++ % 4];
        sfx(f, 'sawtooth', 1.5, 0.1); 
    }, 800);
}

// --- УПРАВЛЕНИЕ (JOYSTICK + KEYBOARD for TV) ---
const inputVector = new THREE.Vector2(0, 0);
let joyCenter = { x: 0, y: 0 }; let isDrag = false;

function joyStart(e) { if(!gameState.playing) return; isDrag=true; const r = ui.joyBase.getBoundingClientRect(); joyCenter={x:r.left+r.width/2, y:r.top+r.height/2}; joyMove(e); }
function joyMove(e) { 
    if(!isDrag) return; 
    const cx = e.touches?e.touches[0].clientX:e.clientX; const cy = e.touches?e.touches[0].clientY:e.clientY;
    let dx = cx-joyCenter.x; let dy = cy-joyCenter.y;
    const max = ui.joyBase.offsetWidth/2; const d = Math.sqrt(dx*dx+dy*dy);
    if(d>max) { const r=max/d; dx*=r; dy*=r; }
    ui.joyKnob.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`;
    inputVector.x=dx/max; inputVector.y=-dy/max;
}
function joyEnd() { isDrag=false; ui.joyKnob.style.transform=`translate(-50%,-50%)`; inputVector.set(0,0); }

ui.joyBase.addEventListener('pointerdown', joyStart);
window.addEventListener('pointermove', joyMove);
window.addEventListener('pointerup', joyEnd);
window.addEventListener('pointercancel', joyEnd);

// KEYBOARD SUPPORT (Android TV / Desktop)
window.addEventListener('keydown', (e) => {
    if(e.code === 'Enter') {
        if(ui.startScreen.style.display !== 'none') startGame();
        else if(ui.gameOverScreen.style.display !== 'none') toMenu();
    }
    if(e.code === 'Escape') {
        if(gameState.playing) gameOver();
    }
    // Simple arrow keys
    if(gameState.playing) {
        if(e.code === 'ArrowUp') inputVector.y = 1;
        if(e.code === 'ArrowDown') inputVector.y = -1;
        if(e.code === 'ArrowLeft') inputVector.x = -1;
        if(e.code === 'ArrowRight') inputVector.x = 1;
    }
});
window.addEventListener('keyup', () => { inputVector.set(0,0); });


// SCENE
const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x3a2334, 0.08); scene.background = new THREE.Color(0x1a0a1a);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 80);
const renderer = new THREE.WebGLRenderer({ antialias: false });
// Оптимизация для TV (Violation 1.14)
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('game-container').appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x886677, 0.6));

const rawMap = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,0,0,1,0,0,0,0,0,3,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,1,2,1,1,0,1,1,0,1],
    [1,0,0,0,0,1,9,9,9,1,0,0,0,0,1],
    [1,0,1,1,0,1,1,1,1,1,0,1,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,3,0,0,0,0,0,0,0,3,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
const mapW = rawMap[0].length; const mapH = rawMap.length;
const matWood = new THREE.MeshStandardMaterial({color: 0x443322});
const matTree = new THREE.MeshStandardMaterial({color: 0x051105, flatShading:true});
const matDot = new THREE.MeshBasicMaterial({color: 0xffddaa});
const matPower = new THREE.MeshStandardMaterial({color: 0xff3333, emissive: 0x550000});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({color: 0x111122}));
floor.rotation.x = -Math.PI/2; scene.add(floor);

let walls = []; let dots = []; let powers = []; let ghosts = []; let playerStartPos = new THREE.Vector3(0, 1.7, 0);

function createBlock(x, z) {
    const g = new THREE.Group(); g.position.set(x,0,z);
    const post = new THREE.Mesh(new THREE.BoxGeometry(0.3,1.8,0.3), matWood);
    [[-1.9,1.9],[1.9,1.9],[1.9,-1.9],[-1.9,-1.9]].forEach(p=>{const m=post.clone(); m.position.set(p[0],0.9,p[1]); g.add(m)});
    const t=new THREE.Mesh(new THREE.ConeGeometry(1.2,6,5), matTree); t.position.y=3; g.add(t);
    scene.add(g); walls.push({x:x, z:z});
}

class Ghost {
    constructor(color, x, z) {
        this.color = color; this.startPos = new THREE.Vector3(x, 2, z);
        this.mesh = new THREE.Group(); this.mesh.position.copy(this.startPos);
        const b = new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.4,2.2,8,1,true), new THREE.MeshStandardMaterial({color:color,transparent:true,opacity:0.8,emissive:color,emissiveIntensity:0.2}));
        b.position.y=1.1; this.mesh.add(b);
        const e = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshBasicMaterial({color:0xffffff}));
        const e1=e.clone(); e1.position.set(-0.3,1.5,0.5); const e2=e.clone(); e2.position.set(0.3,1.5,0.5);
        this.mesh.add(e1,e2); scene.add(this.mesh);
        this.dir = new THREE.Vector3(1,0,0); this.state = 'normal';
    }
    update() {
        const s = this.state === 'frightened' ? 0.03 : CONFIG.baseGhostSpeed;
        const np = this.mesh.position.clone().add(this.dir.clone().multiplyScalar(s));
        if(!checkCol(np)) this.mesh.position.copy(np);
        else { const a = Math.random()*6.28; this.dir.set(Math.cos(a),0,Math.sin(a)); }
        this.mesh.position.y = 2 + Math.sin(Date.now()*0.003 + this.mesh.id)*0.2;
        this.mesh.lookAt(camera.position);
        this.mesh.children[0].material.color.setHex(this.state==='frightened'?0x5555ff:this.color);
    }
}
function checkCol(p) { for(let w of walls) if(Math.abs(p.x-w.x)<2.2 && Math.abs(p.z-w.z)<2.2) return true; return false; }

function buildLevel() {
    ghosts.forEach(g=>scene.remove(g.mesh)); ghosts=[];
    dots.forEach(d=>scene.remove(d)); dots=[]; powers.forEach(p=>scene.remove(p)); powers=[];
    const exists = walls.length > 0; gameState.dotsLeft=0;
    for(let z=0; z<mapH; z++) for(let x=0; x<mapW; x++) {
        const t=rawMap[z][x]; const wx=(x-mapW/2)*4; const wz=(z-mapH/2)*4;
        if(!exists && t===1) createBlock(wx,wz);
        if(t===0) { const d=new THREE.Mesh(new THREE.SphereGeometry(0.3),matDot); d.position.set(wx,1,wz); scene.add(d); dots.push(d); gameState.dotsLeft++; }
        if(t===3) { const p=new THREE.Mesh(new THREE.DodecahedronGeometry(0.6),matPower); p.position.set(wx,1,wz); scene.add(p); powers.push(p); }
        if(t===2) playerStartPos.set(wx,1.7,wz);
        if(t===9) ghosts.push(new Ghost(0xaa0000,wx,wz));
    }
    camera.position.copy(playerStartPos); camera.rotation.set(0,0,0);
}

function startGame() {
    ui.startScreen.style.display='none'; ui.gameOverScreen.style.display='none';
    ui.gameUI.style.display='block'; // Показываем интерфейс
    gameState.score=0; gameState.lives=3; gameState.level=1;
    ui.score.innerText='0'; ui.lives.innerText='3';
    if(audioCtx.state==='suspended') audioCtx.resume();
    audioReady=true; startMusic(); buildLevel(); gameState.playing=true;
}
function gameOver() {
    gameState.playing=false; saveScorePlatform(gameState.score);
    ui.finalScore.innerText=gameState.score; ui.gameUI.style.display='none'; ui.gameOverScreen.style.display='flex';
}
function toMenu() { 
    showAd(()=>{ 
        ui.gameOverScreen.style.display='none'; 
        ui.startScreen.style.display='flex'; 
        refreshLeaderboard(); 
    }); 
}

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', toMenu);

const axe=new THREE.Group(); 
const ah=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.5,0.1),matWood); const ab=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.3,0.05),new THREE.MeshStandardMaterial({color:0x555566}));
ah.position.y=-0.5; ab.position.set(0.15,0.2,0); axe.add(ah,ab); axe.position.set(0.5,-0.6,-1); axe.rotation.set(0.3,-0.2,0); camera.add(axe);
const fwd = new THREE.Vector3();

function animate() {
    requestAnimationFrame(animate);
    if(gameState.playing) {
        camera.rotation.y -= inputVector.x * CONFIG.rotSpeed;
        fwd.set(0,0,-1).applyQuaternion(camera.quaternion).normalize();
        const np = camera.position.clone();
        const s = inputVector.y > 0 ? CONFIG.baseMoveSpeed : CONFIG.baseMoveSpeed * 0.6;
        if(Math.abs(inputVector.y) > 0.1) {
            np.add(fwd.multiplyScalar(inputVector.y * s));
            if(!checkCol(np)) { camera.position.copy(np); camera.position.y = 1.7+Math.sin(Date.now()*0.015)*0.05; axe.position.y = -0.6+Math.sin(Date.now()*0.015)*0.03; }
        } else axe.position.y = THREE.MathUtils.lerp(axe.position.y, -0.6, 0.1);

        for(let i=dots.length-1; i>=0; i--) if(camera.position.distanceTo(dots[i].position)<1) { scene.remove(dots[i]); dots.splice(i,1); gameState.score+=10; ui.score.innerText=gameState.score; gameState.dotsLeft--; sfx(880,'square',0.1,0.1); if(gameState.dotsLeft===0){gameState.level++; buildLevel();} }
        for(let i=powers.length-1; i>=0; i--) if(camera.position.distanceTo(powers[i].position)<1) { scene.remove(powers[i]); powers.splice(i,1); gameState.powerMode=true; ghosts.forEach(g=>g.state='frightened'); setTimeout(()=>{gameState.powerMode=false; ghosts.forEach(g=>g.state='normal');}, CONFIG.powerDuration); sfx(200,'sawtooth',0.5,0.3); }
        
        ghosts.forEach(g => {
            g.update();
            if(camera.position.distanceTo(g.mesh.position) < 1.5) {
                if(g.state==='frightened') { g.mesh.position.y=-10; gameState.score+=200; ui.score.innerText=gameState.score; sfx(400,'triangle',0.3,0.3); }
                else if(g.state==='normal') { gameState.lives--; ui.lives.innerText=gameState.lives; camera.position.copy(playerStartPos); sfx(100,'sawtooth',0.5,0.5); if(gameState.lives<=0) gameOver(); }
            }
        });
    }
    renderer.render(scene, camera);
}
animate();
window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
